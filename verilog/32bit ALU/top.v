//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro

   /*
   Copyright 2023 Redwood EDA, LLC
   
   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
//_\source top.tlv 41
//_\SV
   // Include WARP-V.
   
   // Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v/b89fa754262d7d369cf991c09a7c438bc94dd260/warp-v.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_lib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentals_lib.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/b4c0b50a17d386259be34b03384803609c625d80/risc-v_defs.tlv"
   /* verilator lint_off WIDTH */
   /* verilator lint_off PINMISSING */
   /* verilator lint_off SELRANGE */
   /* verilator lint_off WIDTH */
   /* verilator lint_off CASEINCOMPLETE */
   `include "./sv_url_inc/picorv32_pcpi_div.sv"  // From: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/b4c0b50a17d386259be34b03384803609c625d80/divmul/picorv32_pcpi_div.sv"
   `include "./sv_url_inc/picorv32_pcpi_fast_mul.sv"  // From: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/b4c0b50a17d386259be34b03384803609c625d80/divmul/picorv32_pcpi_fast_mul.sv"
   /* verilator lint_on CASEINCOMPLETE */
   /* verilator lint_on WIDTH */

//_\SV
   module top(input wire clk, input wire reset, input wire [31:0] cyc_cnt, output wire passed, output wire failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
//_\source top.tlv 47
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------

// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar bank, instr_mem, mem, pipe_ctrl_instr, pipe_ctrl_stage, regs, src;


//
// Signals declared top-level.
//

// For |fetch/instr$Cnt.
logic [7:0] FETCH_Instr_Cnt_n2,
            FETCH_Instr_Cnt_n1;

// For |fetch/instr$GoodPathMask.
logic [1+1:0] FETCH_Instr_GoodPathMask_n1,
              FETCH_Instr_GoodPathMask_a0;

// For |fetch/instr$NoFetch.
logic FETCH_Instr_NoFetch_n1,
      FETCH_Instr_NoFetch_a0,
      FETCH_Instr_NoFetch_a1;

// For |fetch/instr$Pc.
logic [31:2] FETCH_Instr_Pc_n1,
             FETCH_Instr_Pc_a0;

// For |fetch/instr$RemainingCyclesWithinTimeUnit.
logic [30-1:0] FETCH_Instr_RemainingCyclesWithinTimeUnit_n1,
               FETCH_Instr_RemainingCyclesWithinTimeUnit_a0;

// For |fetch/instr$abort.
logic FETCH_Instr_abort_a0;

// For |fetch/instr$aborting_isa_trap.
logic FETCH_Instr_aborting_isa_trap_a0;

// For |fetch/instr$aborting_trap.
logic FETCH_Instr_aborting_trap_a0,
      FETCH_Instr_aborting_trap_a1;

// For |fetch/instr$add_rslt.
logic [31:0] FETCH_Instr_add_rslt_a0;

// For |fetch/instr$add_sub_rslt.
logic [31:0] FETCH_Instr_add_sub_rslt_a0;

// For |fetch/instr$addi_rslt.
logic [31:0] FETCH_Instr_addi_rslt_a0;

// For |fetch/instr$addr.
logic [31:0] FETCH_Instr_addr_a0;

// For |fetch/instr$and_rslt.
logic [31:0] FETCH_Instr_and_rslt_a0;

// For |fetch/instr$andi_rslt.
logic [31:0] FETCH_Instr_andi_rslt_a0;

// For |fetch/instr$auipc_rslt.
logic [31:0] FETCH_Instr_auipc_rslt_a0;

// For |fetch/instr$branch.
logic FETCH_Instr_branch_a0;

// For |fetch/instr$branch_redir_pc.
logic [31:2] FETCH_Instr_branch_redir_pc_a0;

// For |fetch/instr$branch_target.
logic [31:2] FETCH_Instr_branch_target_a0;

// For |fetch/instr$clk.
logic FETCH_Instr_clk_a0;

// For |fetch/instr$commit.
logic FETCH_Instr_commit_a0;

// For |fetch/instr$conditional_branch.
logic FETCH_Instr_conditional_branch_a0;

// For |fetch/instr$csr_cycle.
logic [31:0] FETCH_Instr_csr_cycle_n1,
             FETCH_Instr_csr_cycle_a0;

// For |fetch/instr$csr_cycle_hw_wr.
logic FETCH_Instr_csr_cycle_hw_wr_a0;

// For |fetch/instr$csr_cycle_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_en_mask_a0;

// For |fetch/instr$csr_cycle_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_mask_a0;

// For |fetch/instr$csr_cycle_hw_wr_value.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_value_a0;

// For |fetch/instr$csr_cycle_masked_wr_value.
logic [31:0] FETCH_Instr_csr_cycle_masked_wr_value_a0;

// For |fetch/instr$csr_cycleh.
logic [31:0] FETCH_Instr_csr_cycleh_n1,
             FETCH_Instr_csr_cycleh_a0;

// For |fetch/instr$csr_cycleh_hw_wr.
logic FETCH_Instr_csr_cycleh_hw_wr_a0;

// For |fetch/instr$csr_cycleh_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0;

// For |fetch/instr$csr_cycleh_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_mask_a0;

// For |fetch/instr$csr_cycleh_hw_wr_value.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_value_a0;

// For |fetch/instr$csr_cycleh_masked_wr_value.
logic [31:0] FETCH_Instr_csr_cycleh_masked_wr_value_a0;

// For |fetch/instr$csr_instret.
logic [31:0] FETCH_Instr_csr_instret_n1,
             FETCH_Instr_csr_instret_a0;

// For |fetch/instr$csr_instret_hw_wr.
logic FETCH_Instr_csr_instret_hw_wr_a0;

// For |fetch/instr$csr_instret_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_en_mask_a0;

// For |fetch/instr$csr_instret_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_mask_a0;

// For |fetch/instr$csr_instret_hw_wr_value.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_value_a0;

// For |fetch/instr$csr_instret_masked_wr_value.
logic [31:0] FETCH_Instr_csr_instret_masked_wr_value_a0;

// For |fetch/instr$csr_instreth.
logic [31:0] FETCH_Instr_csr_instreth_n1,
             FETCH_Instr_csr_instreth_a0;

// For |fetch/instr$csr_instreth_hw_wr.
logic FETCH_Instr_csr_instreth_hw_wr_a0;

// For |fetch/instr$csr_instreth_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_en_mask_a0;

// For |fetch/instr$csr_instreth_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_mask_a0;

// For |fetch/instr$csr_instreth_hw_wr_value.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_value_a0;

// For |fetch/instr$csr_instreth_masked_wr_value.
logic [31:0] FETCH_Instr_csr_instreth_masked_wr_value_a0;

// For |fetch/instr$csr_time.
logic [31:0] FETCH_Instr_csr_time_n1,
             FETCH_Instr_csr_time_a0;

// For |fetch/instr$csr_time_hw_wr.
logic FETCH_Instr_csr_time_hw_wr_a0;

// For |fetch/instr$csr_time_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_time_hw_wr_en_mask_a0;

// For |fetch/instr$csr_time_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_time_hw_wr_mask_a0;

// For |fetch/instr$csr_time_hw_wr_value.
logic [31:0] FETCH_Instr_csr_time_hw_wr_value_a0;

// For |fetch/instr$csr_time_masked_wr_value.
logic [31:0] FETCH_Instr_csr_time_masked_wr_value_a0;

// For |fetch/instr$csr_timeh.
logic [31:0] FETCH_Instr_csr_timeh_n1,
             FETCH_Instr_csr_timeh_a0;

// For |fetch/instr$csr_timeh_hw_wr.
logic FETCH_Instr_csr_timeh_hw_wr_a0;

// For |fetch/instr$csr_timeh_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_en_mask_a0;

// For |fetch/instr$csr_timeh_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_mask_a0;

// For |fetch/instr$csr_timeh_hw_wr_value.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_value_a0;

// For |fetch/instr$csr_timeh_masked_wr_value.
logic [31:0] FETCH_Instr_csr_timeh_masked_wr_value_a0;

// For |fetch/instr$csr_trap.
logic FETCH_Instr_csr_trap_a0;

// For |fetch/instr$csr_wr_value.
logic [31:0] FETCH_Instr_csr_wr_value_a0;

// For |fetch/instr$csrrc_rslt.
logic [31:0] FETCH_Instr_csrrc_rslt_a0;

// For |fetch/instr$csrrci_rslt.
logic [31:0] FETCH_Instr_csrrci_rslt_a0;

// For |fetch/instr$csrrs_rslt.
logic [31:0] FETCH_Instr_csrrs_rslt_a0;

// For |fetch/instr$csrrsi_rslt.
logic [31:0] FETCH_Instr_csrrsi_rslt_a0;

// For |fetch/instr$csrrw_rslt.
logic [31:0] FETCH_Instr_csrrw_rslt_a0;

// For |fetch/instr$csrrwi_rslt.
logic [31:0] FETCH_Instr_csrrwi_rslt_a0;

// For |fetch/instr$dest_pending.
logic FETCH_Instr_dest_pending_a0;

// For |fetch/instr$dest_reg.
logic [4:0] FETCH_Instr_dest_reg_a0;

// For |fetch/instr$dest_reg_valid.
logic FETCH_Instr_dest_reg_valid_a0;

// For |fetch/instr$div_in1.
logic [31:0] FETCH_Instr_div_in1_a0,
             FETCH_Instr_div_in1_a1;

// For |fetch/instr$div_in2.
logic [31:0] FETCH_Instr_div_in2_a0,
             FETCH_Instr_div_in2_a1;

// For |fetch/instr$div_mul.
logic FETCH_Instr_div_mul_a0;

// For |fetch/instr$div_rslt.
logic [31:0] FETCH_Instr_div_rslt_a0;

// For |fetch/instr$div_stall.
logic FETCH_Instr_div_stall_a0,
      FETCH_Instr_div_stall_a1;

// For |fetch/instr$divblk_valid.
logic FETCH_Instr_divblk_valid_a0;

// For |fetch/instr$divblock_rslt.
logic [31:0] FETCH_Instr_divblock_rslt_a0;

// For |fetch/instr$divtype_instr.
logic FETCH_Instr_divtype_instr_a0;

// For |fetch/instr$divu_rslt.
logic [31:0] FETCH_Instr_divu_rslt_a0;

// For |fetch/instr$equal.
logic FETCH_Instr_equal_a0;

// For |fetch/instr$failed.
logic FETCH_Instr_failed_a0;

// For |fetch/instr$fetch.
logic FETCH_Instr_fetch_a0;

// For |fetch/instr$first_issue.
logic FETCH_Instr_first_issue_a0;

// For |fetch/instr$full_csr_cycle_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_cycle_hw_wr_value_a0;

// For |fetch/instr$full_csr_instret_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_instret_hw_wr_value_a0;

// For |fetch/instr$full_csr_time_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_time_hw_wr_value_a0;

// For |fetch/instr$good_path.
logic FETCH_Instr_good_path_a0;

// For |fetch/instr$illegal.
logic FETCH_Instr_illegal_a0;

// For |fetch/instr$illegal_itype_with_funct7.
logic FETCH_Instr_illegal_itype_with_funct7_a0;

// For |fetch/instr$imm_valid.
logic FETCH_Instr_imm_valid_a0;

// For |fetch/instr$imm_value.
logic [31:0] FETCH_Instr_imm_value_a0;

// For |fetch/instr$indirect_jump.
logic FETCH_Instr_indirect_jump_a0;

// For |fetch/instr$indirect_jump_full_target.
logic [31:0] FETCH_Instr_indirect_jump_full_target_a0;

// For |fetch/instr$indirect_jump_target.
logic [31:2] FETCH_Instr_indirect_jump_target_a0;

// For |fetch/instr$instr_type_div.
logic [3:0] FETCH_Instr_instr_type_div_a0,
            FETCH_Instr_instr_type_div_a1;

// For |fetch/instr$instr_type_mul.
logic [3:0] FETCH_Instr_instr_type_mul_a0,
            FETCH_Instr_instr_type_mul_a1;

// For |fetch/instr$is___type.
logic FETCH_Instr_is___type_a0;

// For |fetch/instr$is_add_instr.
logic FETCH_Instr_is_add_instr_a0;

// For |fetch/instr$is_addi_instr.
logic FETCH_Instr_is_addi_instr_a0;

// For |fetch/instr$is_and_instr.
logic FETCH_Instr_is_and_instr_a0;

// For |fetch/instr$is_andi_instr.
logic FETCH_Instr_is_andi_instr_a0;

// For |fetch/instr$is_auipc_instr.
logic FETCH_Instr_is_auipc_instr_a0;

// For |fetch/instr$is_b_type.
logic FETCH_Instr_is_b_type_a0;

// For |fetch/instr$is_beq_instr.
logic FETCH_Instr_is_beq_instr_a0;

// For |fetch/instr$is_bge_instr.
logic FETCH_Instr_is_bge_instr_a0;

// For |fetch/instr$is_bgeu_instr.
logic FETCH_Instr_is_bgeu_instr_a0;

// For |fetch/instr$is_blt_instr.
logic FETCH_Instr_is_blt_instr_a0;

// For |fetch/instr$is_bltu_instr.
logic FETCH_Instr_is_bltu_instr_a0;

// For |fetch/instr$is_bne_instr.
logic FETCH_Instr_is_bne_instr_a0;

// For |fetch/instr$is_csr_clear.
logic FETCH_Instr_is_csr_clear_a0;

// For |fetch/instr$is_csr_cycle.
logic FETCH_Instr_is_csr_cycle_a0;

// For |fetch/instr$is_csr_cycleh.
logic FETCH_Instr_is_csr_cycleh_a0;

// For |fetch/instr$is_csr_instr.
logic FETCH_Instr_is_csr_instr_a0;

// For |fetch/instr$is_csr_instret.
logic FETCH_Instr_is_csr_instret_a0;

// For |fetch/instr$is_csr_instreth.
logic FETCH_Instr_is_csr_instreth_a0;

// For |fetch/instr$is_csr_set.
logic FETCH_Instr_is_csr_set_a0;

// For |fetch/instr$is_csr_time.
logic FETCH_Instr_is_csr_time_a0;

// For |fetch/instr$is_csr_timeh.
logic FETCH_Instr_is_csr_timeh_a0;

// For |fetch/instr$is_csr_write.
logic FETCH_Instr_is_csr_write_a0;

// For |fetch/instr$is_csrrc_instr.
logic FETCH_Instr_is_csrrc_instr_a0;

// For |fetch/instr$is_csrrci_instr.
logic FETCH_Instr_is_csrrci_instr_a0;

// For |fetch/instr$is_csrrs_instr.
logic FETCH_Instr_is_csrrs_instr_a0;

// For |fetch/instr$is_csrrsi_instr.
logic FETCH_Instr_is_csrrsi_instr_a0;

// For |fetch/instr$is_csrrw_instr.
logic FETCH_Instr_is_csrrw_instr_a0;

// For |fetch/instr$is_csrrwi_instr.
logic FETCH_Instr_is_csrrwi_instr_a0;

// For |fetch/instr$is_dest_condition.
logic FETCH_Instr_is_dest_condition_a0;

// For |fetch/instr$is_div_instr.
logic FETCH_Instr_is_div_instr_a0;

// For |fetch/instr$is_divu_instr.
logic FETCH_Instr_is_divu_instr_a0;

// For |fetch/instr$is_i_type.
logic FETCH_Instr_is_i_type_a0;

// For |fetch/instr$is_j_type.
logic FETCH_Instr_is_j_type_a0;

// For |fetch/instr$is_jal_instr.
logic FETCH_Instr_is_jal_instr_a0;

// For |fetch/instr$is_jalr_instr.
logic FETCH_Instr_is_jalr_instr_a0;

// For |fetch/instr$is_lb_instr.
logic FETCH_Instr_is_lb_instr_a0;

// For |fetch/instr$is_lbu_instr.
logic FETCH_Instr_is_lbu_instr_a0;

// For |fetch/instr$is_lh_instr.
logic FETCH_Instr_is_lh_instr_a0;

// For |fetch/instr$is_lhu_instr.
logic FETCH_Instr_is_lhu_instr_a0;

// For |fetch/instr$is_lui_instr.
logic FETCH_Instr_is_lui_instr_a0;

// For |fetch/instr$is_lw_instr.
logic FETCH_Instr_is_lw_instr_a0;

// For |fetch/instr$is_mul_instr.
logic FETCH_Instr_is_mul_instr_a0;

// For |fetch/instr$is_mulh_instr.
logic FETCH_Instr_is_mulh_instr_a0;

// For |fetch/instr$is_mulhsu_instr.
logic FETCH_Instr_is_mulhsu_instr_a0;

// For |fetch/instr$is_mulhu_instr.
logic FETCH_Instr_is_mulhu_instr_a0;

// For |fetch/instr$is_or_instr.
logic FETCH_Instr_is_or_instr_a0;

// For |fetch/instr$is_ori_instr.
logic FETCH_Instr_is_ori_instr_a0;

// For |fetch/instr$is_r2_type.
logic FETCH_Instr_is_r2_type_a0;

// For |fetch/instr$is_r4_type.
logic FETCH_Instr_is_r4_type_a0;

// For |fetch/instr$is_r_type.
logic FETCH_Instr_is_r_type_a0;

// For |fetch/instr$is_rem_instr.
logic FETCH_Instr_is_rem_instr_a0;

// For |fetch/instr$is_remu_instr.
logic FETCH_Instr_is_remu_instr_a0;

// For |fetch/instr$is_s_type.
logic FETCH_Instr_is_s_type_a0;

// For |fetch/instr$is_sb_instr.
logic FETCH_Instr_is_sb_instr_a0;

// For |fetch/instr$is_sh_instr.
logic FETCH_Instr_is_sh_instr_a0;

// For |fetch/instr$is_sll_instr.
logic FETCH_Instr_is_sll_instr_a0;

// For |fetch/instr$is_slli_instr.
logic FETCH_Instr_is_slli_instr_a0;

// For |fetch/instr$is_slt_instr.
logic FETCH_Instr_is_slt_instr_a0;

// For |fetch/instr$is_slti_instr.
logic FETCH_Instr_is_slti_instr_a0;

// For |fetch/instr$is_sltiu_instr.
logic FETCH_Instr_is_sltiu_instr_a0;

// For |fetch/instr$is_sltu_instr.
logic FETCH_Instr_is_sltu_instr_a0;

// For |fetch/instr$is_sra_instr.
logic FETCH_Instr_is_sra_instr_a0;

// For |fetch/instr$is_srai_instr.
logic FETCH_Instr_is_srai_instr_a0;

// For |fetch/instr$is_srl_instr.
logic FETCH_Instr_is_srl_instr_a0;

// For |fetch/instr$is_srli_instr.
logic FETCH_Instr_is_srli_instr_a0;

// For |fetch/instr$is_srli_srai_instr.
logic FETCH_Instr_is_srli_srai_instr_a0;

// For |fetch/instr$is_sub_instr.
logic FETCH_Instr_is_sub_instr_a0;

// For |fetch/instr$is_sw_instr.
logic FETCH_Instr_is_sw_instr_a0;

// For |fetch/instr$is_u_type.
logic FETCH_Instr_is_u_type_a0;

// For |fetch/instr$is_xor_instr.
logic FETCH_Instr_is_xor_instr_a0;

// For |fetch/instr$is_xori_instr.
logic FETCH_Instr_is_xori_instr_a0;

// For |fetch/instr$jal_rslt.
logic [31:0] FETCH_Instr_jal_rslt_a0;

// For |fetch/instr$jalr_rslt.
logic [31:0] FETCH_Instr_jalr_rslt_a0;

// For |fetch/instr$jump.
logic FETCH_Instr_jump_a0;

// For |fetch/instr$jump_target.
logic [31:2] FETCH_Instr_jump_target_a0;

// For |fetch/instr$lb_rslt.
logic [31:0] FETCH_Instr_lb_rslt_a0;

// For |fetch/instr$lbu_rslt.
logic [31:0] FETCH_Instr_lbu_rslt_a0;

// For |fetch/instr$ld.
logic FETCH_Instr_ld_a0;

// For |fetch/instr$ld_data.
logic [31:0] FETCH_Instr_ld_data_a0,
             FETCH_Instr_ld_data_a1;

// For |fetch/instr$ld_st.
logic FETCH_Instr_ld_st_a0;

// For |fetch/instr$ld_st_cond.
logic FETCH_Instr_ld_st_cond_a0;

// For |fetch/instr$ld_st_half.
logic FETCH_Instr_ld_st_half_a0;

// For |fetch/instr$ld_st_word.
logic FETCH_Instr_ld_st_word_a0;

// For |fetch/instr$lh_rslt.
logic [31:0] FETCH_Instr_lh_rslt_a0;

// For |fetch/instr$lhu_rslt.
logic [31:0] FETCH_Instr_lhu_rslt_a0;

// For |fetch/instr$lui_rslt.
logic [31:0] FETCH_Instr_lui_rslt_a0;

// For |fetch/instr$lw_rslt.
logic [31:0] FETCH_Instr_lw_rslt_a0;

// For |fetch/instr$misaligned_indirect_jump_target.
logic FETCH_Instr_misaligned_indirect_jump_target_a0;

// For |fetch/instr$misaligned_jump_target.
logic FETCH_Instr_misaligned_jump_target_a0;

// For |fetch/instr$misaligned_pc.
logic FETCH_Instr_misaligned_pc_a0;

// For |fetch/instr$mispred_branch.
logic FETCH_Instr_mispred_branch_a0;

// For |fetch/instr$mnemonic.
logic [10*8-1:0] FETCH_Instr_mnemonic_a0;

// For |fetch/instr$mul_in1.
logic [31:0] FETCH_Instr_mul_in1_a0,
             FETCH_Instr_mul_in1_a1;

// For |fetch/instr$mul_in2.
logic [31:0] FETCH_Instr_mul_in2_a0,
             FETCH_Instr_mul_in2_a1;

// For |fetch/instr$mul_rslt.
logic [31:0] FETCH_Instr_mul_rslt_a0;

// For |fetch/instr$mul_stall.
logic FETCH_Instr_mul_stall_a0,
      FETCH_Instr_mul_stall_a1;

// For |fetch/instr$mulblk_valid.
logic FETCH_Instr_mulblk_valid_a0;

// For |fetch/instr$mulblock_rslt.
logic [31:0] FETCH_Instr_mulblock_rslt_a0;

// For |fetch/instr$mulh_rslt.
logic [31:0] FETCH_Instr_mulh_rslt_a0;

// For |fetch/instr$mulhsu_rslt.
logic [31:0] FETCH_Instr_mulhsu_rslt_a0;

// For |fetch/instr$mulhu_rslt.
logic [31:0] FETCH_Instr_mulhu_rslt_a0;

// For |fetch/instr$multype_instr.
logic FETCH_Instr_multype_instr_a0;

// For |fetch/instr$next_good_path_mask.
logic [1+1:0] FETCH_Instr_next_good_path_mask_a0;

// For |fetch/instr$next_no_fetch.
logic FETCH_Instr_next_no_fetch_a0;

// For |fetch/instr$next_pc.
logic [31:2] FETCH_Instr_next_pc_a0;

// For |fetch/instr$non_aborting_isa_trap.
logic FETCH_Instr_non_aborting_isa_trap_a0;

// For |fetch/instr$non_aborting_trap.
logic FETCH_Instr_non_aborting_trap_a0,
      FETCH_Instr_non_aborting_trap_a1;

// For |fetch/instr$non_pipelined.
logic FETCH_Instr_non_pipelined_a0,
      FETCH_Instr_non_pipelined_a1;

// For |fetch/instr$or_rslt.
logic [31:0] FETCH_Instr_or_rslt_a0;

// For |fetch/instr$ori_rslt.
logic [31:0] FETCH_Instr_ori_rslt_a0;

// For |fetch/instr$passed.
logic FETCH_Instr_passed_a0;

// For |fetch/instr$pc.
logic [31:2] FETCH_Instr_pc_a0;

// For |fetch/instr$pc_inc.
logic [31:2] FETCH_Instr_pc_inc_a0,
             FETCH_Instr_pc_inc_a1;

// For |fetch/instr$pending_replay.
logic FETCH_Instr_pending_replay_a0;

// For |fetch/instr$pred_taken.
logic FETCH_Instr_pred_taken_a0;

// For |fetch/instr$raw.
logic [31:0] FETCH_Instr_raw_a0;

// For |fetch/instr$raw_aq.
logic FETCH_Instr_raw_aq_a0;

// For |fetch/instr$raw_b_imm.
logic [31:0] FETCH_Instr_raw_b_imm_a0;

// For |fetch/instr$raw_funct3.
logic [2:0] FETCH_Instr_raw_funct3_a0;

// For |fetch/instr$raw_funct7.
logic [6:0] FETCH_Instr_raw_funct7_a0;

// For |fetch/instr$raw_i_imm.
logic [31:0] FETCH_Instr_raw_i_imm_a0;

// For |fetch/instr$raw_j_imm.
logic [31:0] FETCH_Instr_raw_j_imm_a0;

// For |fetch/instr$raw_op2.
logic [1:0] FETCH_Instr_raw_op2_a0;

// For |fetch/instr$raw_op5.
logic [4:0] FETCH_Instr_raw_op5_a0;

// For |fetch/instr$raw_rd.
logic [4:0] FETCH_Instr_raw_rd_a0;

// For |fetch/instr$raw_rl.
logic FETCH_Instr_raw_rl_a0;

// For |fetch/instr$raw_rm.
logic [2:0] FETCH_Instr_raw_rm_a0;

// For |fetch/instr$raw_rs1.
logic [4:0] FETCH_Instr_raw_rs1_a0;

// For |fetch/instr$raw_rs2.
logic [4:0] FETCH_Instr_raw_rs2_a0;

// For |fetch/instr$raw_rs3.
logic [4:0] FETCH_Instr_raw_rs3_a0;

// For |fetch/instr$raw_s_imm.
logic [31:0] FETCH_Instr_raw_s_imm_a0;

// For |fetch/instr$raw_shamt.
logic [6:0] FETCH_Instr_raw_shamt_a0;

// For |fetch/instr$raw_u_imm.
logic [31:0] FETCH_Instr_raw_u_imm_a0;

// For |fetch/instr$readyd.
logic FETCH_Instr_readyd_a0;

// For |fetch/instr$readym.
logic FETCH_Instr_readym_a0;

// For |fetch/instr$reg_wr_pending.
logic FETCH_Instr_reg_wr_pending_a0;

// For |fetch/instr$rem_rslt.
logic [31:0] FETCH_Instr_rem_rslt_a0;

// For |fetch/instr$remu_rslt.
logic [31:0] FETCH_Instr_remu_rslt_a0;

// For |fetch/instr$replay.
logic FETCH_Instr_replay_a0,
      FETCH_Instr_replay_a1;

// For |fetch/instr$replay_trap.
logic FETCH_Instr_replay_trap_a0;

// For |fetch/instr$reset.
logic FETCH_Instr_reset_n1,
      FETCH_Instr_reset_a0;

// For |fetch/instr$resetn.
logic FETCH_Instr_resetn_a0;

// For |fetch/instr$rslt.
logic [31:0] FETCH_Instr_rslt_a0;

// For |fetch/instr$second_issue.
logic FETCH_Instr_second_issue_a0,
      FETCH_Instr_second_issue_a1;

// For |fetch/instr$second_issue_div_mul.
logic FETCH_Instr_second_issue_div_mul_a0;

// For |fetch/instr$second_issue_ld.
logic FETCH_Instr_second_issue_ld_a0;

// For |fetch/instr$sll_rslt.
logic [31:0] FETCH_Instr_sll_rslt_a0;

// For |fetch/instr$slli_rslt.
logic [31:0] FETCH_Instr_slli_rslt_a0;

// For |fetch/instr$slt_rslt.
logic [31:0] FETCH_Instr_slt_rslt_a0;

// For |fetch/instr$slti_rslt.
logic [31:0] FETCH_Instr_slti_rslt_a0;

// For |fetch/instr$sltiu_rslt.
logic [31:0] FETCH_Instr_sltiu_rslt_a0;

// For |fetch/instr$sltu_rslt.
logic [31:0] FETCH_Instr_sltu_rslt_a0;

// For |fetch/instr$soft_reset.
logic FETCH_Instr_soft_reset_n1;

// For |fetch/instr$spec_ld.
logic FETCH_Instr_spec_ld_a0;

// For |fetch/instr$sra_rslt.
logic [31:0] FETCH_Instr_sra_rslt_a0;

// For |fetch/instr$srai_intermediate_rslt.
logic [31:0] FETCH_Instr_srai_intermediate_rslt_a0;

// For |fetch/instr$srai_rslt.
logic [31:0] FETCH_Instr_srai_rslt_a0;

// For |fetch/instr$srl_rslt.
logic [31:0] FETCH_Instr_srl_rslt_a0;

// For |fetch/instr$srli_intermediate_rslt.
logic [31:0] FETCH_Instr_srli_intermediate_rslt_a0;

// For |fetch/instr$srli_rslt.
logic [31:0] FETCH_Instr_srli_rslt_a0;

// For |fetch/instr$st.
logic FETCH_Instr_st_a0;

// For |fetch/instr$st_cond.
logic FETCH_Instr_st_cond_a0;

// For |fetch/instr$st_mask.
logic [3:0] FETCH_Instr_st_mask_a0;

// For |fetch/instr$st_reg_value.
logic [31:0] FETCH_Instr_st_reg_value_a0;

// For |fetch/instr$st_value.
logic [31:0] FETCH_Instr_st_value_a0;

// For |fetch/instr$stall_cnt.
logic [5:0] FETCH_Instr_stall_cnt_a0,
            FETCH_Instr_stall_cnt_a1;

// For |fetch/instr$stall_cnt_upper_div.
logic FETCH_Instr_stall_cnt_upper_div_a0,
      FETCH_Instr_stall_cnt_upper_div_a1;

// For |fetch/instr$stall_cnt_upper_mul.
logic FETCH_Instr_stall_cnt_upper_mul_a0,
      FETCH_Instr_stall_cnt_upper_mul_a1;

// For |fetch/instr$sub_rslt.
logic [31:0] FETCH_Instr_sub_rslt_a0;

// For |fetch/instr$taken.
logic FETCH_Instr_taken_a0;

// For |fetch/instr$time_unit_expires.
logic FETCH_Instr_time_unit_expires_a0;

// For |fetch/instr$trap_target.
logic [31:2] FETCH_Instr_trap_target_a0,
             FETCH_Instr_trap_target_a1;

// For |fetch/instr$trigger_next_pc_div_mul_second_issue.
logic FETCH_Instr_trigger_next_pc_div_mul_second_issue_a0,
      FETCH_Instr_trigger_next_pc_div_mul_second_issue_a1;

// For |fetch/instr$unnatural_addr_trap.
logic FETCH_Instr_unnatural_addr_trap_a0;

// For |fetch/instr$upd_csr_cycle.
logic [31:0] FETCH_Instr_upd_csr_cycle_a0;

// For |fetch/instr$upd_csr_cycleh.
logic [31:0] FETCH_Instr_upd_csr_cycleh_a0;

// For |fetch/instr$upd_csr_instret.
logic [31:0] FETCH_Instr_upd_csr_instret_a0;

// For |fetch/instr$upd_csr_instreth.
logic [31:0] FETCH_Instr_upd_csr_instreth_a0;

// For |fetch/instr$upd_csr_time.
logic [31:0] FETCH_Instr_upd_csr_time_a0;

// For |fetch/instr$upd_csr_timeh.
logic [31:0] FETCH_Instr_upd_csr_timeh_a0;

// For |fetch/instr$valid_csr.
logic FETCH_Instr_valid_csr_a0;

// For |fetch/instr$valid_decode.
logic FETCH_Instr_valid_decode_a0;

// For |fetch/instr$valid_decode_branch.
logic FETCH_Instr_valid_decode_branch_a0;

// For |fetch/instr$valid_dest_reg_valid.
logic FETCH_Instr_valid_dest_reg_valid_a0;

// For |fetch/instr$valid_exe.
logic FETCH_Instr_valid_exe_a0;

// For |fetch/instr$valid_ld.
logic FETCH_Instr_valid_ld_a0;

// For |fetch/instr$valid_st.
logic FETCH_Instr_valid_st_a0;

// For |fetch/instr$waitd.
logic FETCH_Instr_waitd_a0;

// For |fetch/instr$waitm.
logic FETCH_Instr_waitm_a0;

// For |fetch/instr$wrd.
logic FETCH_Instr_wrd_a0;

// For |fetch/instr$wrm.
logic FETCH_Instr_wrm_a0;

// For |fetch/instr$xor_rslt.
logic [31:0] FETCH_Instr_xor_rslt_a0;

// For |fetch/instr$xori_rslt.
logic [31:0] FETCH_Instr_xori_rslt_a0;

// For |fetch/instr/div1$div_insn.
logic [31:0] FETCH_Instr_Div1_div_insn_a0;

// For |fetch/instr/div1$opcode.
logic [2:0] FETCH_Instr_Div1_opcode_a0;

// For |fetch/instr/hold_inst$dest_reg.
logic [4:0] FETCH_Instr_HoldInst_dest_reg_a0,
            FETCH_Instr_HoldInst_dest_reg_a1;

// For |fetch/instr/hold_inst$pc.
logic [31:2] FETCH_Instr_HoldInst_pc_a0,
             FETCH_Instr_HoldInst_pc_a1;

// For |fetch/instr/mul1$mul_insn.
logic [31:0] FETCH_Instr_Mul1_mul_insn_a0;

// For |fetch/instr/mul1$opcode.
logic [2:0] FETCH_Instr_Mul1_opcode_a0;

// For |fetch/instr/orig_inst$dest_reg.
logic [4:0] FETCH_Instr_OrigInst_dest_reg_a0;

// For |fetch/instr/orig_inst$pc.
logic [31:2] FETCH_Instr_OrigInst_pc_a0;

// For |fetch/instr/orig_load_inst$addr.
logic [1:0] FETCH_Instr_OrigLoadInst_addr_a0;

// For |fetch/instr/orig_load_inst$dest_reg.
logic [4:0] FETCH_Instr_OrigLoadInst_dest_reg_a0;

// For |fetch/instr/orig_load_inst$g0_spec_ld_cond.
logic FETCH_Instr_OrigLoadInst_g0_spec_ld_cond_a0;

// For |fetch/instr/orig_load_inst$ld_mask.
logic [3:0] FETCH_Instr_OrigLoadInst_ld_mask_a0;

// For |fetch/instr/orig_load_inst$ld_rslt.
logic [31:0] FETCH_Instr_OrigLoadInst_ld_rslt_a0;

// For |fetch/instr/orig_load_inst$ld_st_half.
logic FETCH_Instr_OrigLoadInst_ld_st_half_a0;

// For |fetch/instr/orig_load_inst$ld_st_word.
logic FETCH_Instr_OrigLoadInst_ld_st_word_a0;

// For |fetch/instr/orig_load_inst$ld_value.
logic [31:0] FETCH_Instr_OrigLoadInst_ld_value_a0;

// For |fetch/instr/orig_load_inst$pc.
logic [31:2] FETCH_Instr_OrigLoadInst_pc_a0;

// For |fetch/instr/orig_load_inst$raw_funct3.
logic [2:2] FETCH_Instr_OrigLoadInst_raw_funct3_a0;

// For |fetch/instr/orig_load_inst$sign_bit.
logic FETCH_Instr_OrigLoadInst_sign_bit_a0;

// For |fetch/instr/orig_load_inst$spec_ld.
logic FETCH_Instr_OrigLoadInst_spec_ld_a0;

// For |fetch/instr/orig_load_inst$spec_ld_cond.
logic FETCH_Instr_OrigLoadInst_spec_ld_cond_a0;

// For |fetch/instr/regs$pending.
logic FETCH_Instr_Regs_pending_n1 [31:1],
      FETCH_Instr_Regs_pending_a0 [31:1];

// For |fetch/instr/regs$value.
logic [31:0] FETCH_Instr_Regs_value_a0 [31:1];

// For |fetch/instr/src$replay.
logic [2:1] FETCH_Instr_Src_replay_a0;

// For |fetch/instr/src$unconditioned_is_reg.
logic FETCH_Instr_Src_unconditioned_is_reg_a0 [2:1];

// For |fetch/instr/src$unconditioned_reg.
logic [4:0] FETCH_Instr_Src_unconditioned_reg_a0 [2:1];

// For |fetch/instr/src$unconditioned_reg_value.
logic [31:0] FETCH_Instr_Src_unconditioned_reg_value_a0 [2:1];

// For |fetch/instr_mem$instr_str.
logic [40*8-1:0] FETCH_InstrMem_instr_str_a0 [15:0];

// For |mem/data$addr.
logic [1:0] MEM_Data_addr_a0,
            MEM_Data_addr_a1;

// For |mem/data$dest_reg.
logic [4:0] MEM_Data_dest_reg_a0,
            MEM_Data_dest_reg_a1;

// For |mem/data$ld_st_half.
logic MEM_Data_ld_st_half_a0,
      MEM_Data_ld_st_half_a1;

// For |mem/data$ld_st_word.
logic MEM_Data_ld_st_word_a0,
      MEM_Data_ld_st_word_a1;

// For |mem/data$ld_value.
logic [31:0] MEM_Data_ld_value_a1;

// For |mem/data$pc.
logic [31:2] MEM_Data_pc_a0,
             MEM_Data_pc_a1;

// For |mem/data$raw_funct3.
logic [2:2] MEM_Data_raw_funct3_a0,
            MEM_Data_raw_funct3_a1;

// For |mem/data$spec_ld.
logic MEM_Data_spec_ld_a0,
      MEM_Data_spec_ld_a1;

// For |mem/data$valid_ld.
logic MEM_Data_valid_ld_a0,
      MEM_Data_valid_ld_a1;


//
// Scope: |fetch
//

//
// Scope: |fetch/instr
//

// Clock signals.
logic clkP_FETCH_Instr_valid_exe_a1 ;



   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         // Staging of $Cnt.
         always_ff @(posedge clk) FETCH_Instr_Cnt_n1[7:0] <= FETCH_Instr_Cnt_n2[7:0];

         // Staging of $GoodPathMask.
         always_ff @(posedge clk) FETCH_Instr_GoodPathMask_a0[1+1:0] <= FETCH_Instr_GoodPathMask_n1[1+1:0];

         // Staging of $NoFetch.
         always_ff @(posedge clk) FETCH_Instr_NoFetch_a0 <= FETCH_Instr_NoFetch_n1;
         always_ff @(posedge clk) FETCH_Instr_NoFetch_a1 <= FETCH_Instr_NoFetch_a0;

         // Staging of $Pc.
         always_ff @(posedge clk) FETCH_Instr_Pc_a0[31:2] <= FETCH_Instr_Pc_n1[31:2];

         // Staging of $RemainingCyclesWithinTimeUnit.
         always_ff @(posedge clk) FETCH_Instr_RemainingCyclesWithinTimeUnit_a0[30-1:0] <= FETCH_Instr_RemainingCyclesWithinTimeUnit_n1[30-1:0];

         // Staging of $aborting_trap.
         always_ff @(posedge clk) FETCH_Instr_aborting_trap_a1 <= FETCH_Instr_aborting_trap_a0;

         // Staging of $csr_cycle.
         always_ff @(posedge clk) FETCH_Instr_csr_cycle_a0[31:0] <= FETCH_Instr_csr_cycle_n1[31:0];

         // Staging of $csr_cycleh.
         always_ff @(posedge clk) FETCH_Instr_csr_cycleh_a0[31:0] <= FETCH_Instr_csr_cycleh_n1[31:0];

         // Staging of $csr_instret.
         always_ff @(posedge clk) FETCH_Instr_csr_instret_a0[31:0] <= FETCH_Instr_csr_instret_n1[31:0];

         // Staging of $csr_instreth.
         always_ff @(posedge clk) FETCH_Instr_csr_instreth_a0[31:0] <= FETCH_Instr_csr_instreth_n1[31:0];

         // Staging of $csr_time.
         always_ff @(posedge clk) FETCH_Instr_csr_time_a0[31:0] <= FETCH_Instr_csr_time_n1[31:0];

         // Staging of $csr_timeh.
         always_ff @(posedge clk) FETCH_Instr_csr_timeh_a0[31:0] <= FETCH_Instr_csr_timeh_n1[31:0];

         // Staging of $div_in1.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_div_in1_a1[31:0] <= FETCH_Instr_div_in1_a0[31:0];

         // Staging of $div_in2.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_div_in2_a1[31:0] <= FETCH_Instr_div_in2_a0[31:0];

         // Staging of $div_stall.
         always_ff @(posedge clk) FETCH_Instr_div_stall_a1 <= FETCH_Instr_div_stall_a0;

         // Staging of $instr_type_div.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_instr_type_div_a1[3:0] <= FETCH_Instr_instr_type_div_a0[3:0];

         // Staging of $instr_type_mul.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_instr_type_mul_a1[3:0] <= FETCH_Instr_instr_type_mul_a0[3:0];

         // Staging of $ld_data.
         always_ff @(posedge clk) FETCH_Instr_ld_data_a1[31:0] <= FETCH_Instr_ld_data_a0[31:0];

         // Staging of $mul_in1.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_mul_in1_a1[31:0] <= FETCH_Instr_mul_in1_a0[31:0];

         // Staging of $mul_in2.
         always_ff @(posedge clkP_FETCH_Instr_valid_exe_a1) FETCH_Instr_mul_in2_a1[31:0] <= FETCH_Instr_mul_in2_a0[31:0];

         // Staging of $mul_stall.
         always_ff @(posedge clk) FETCH_Instr_mul_stall_a1 <= FETCH_Instr_mul_stall_a0;

         // Staging of $non_aborting_trap.
         always_ff @(posedge clk) FETCH_Instr_non_aborting_trap_a1 <= FETCH_Instr_non_aborting_trap_a0;

         // Staging of $non_pipelined.
         always_ff @(posedge clk) FETCH_Instr_non_pipelined_a1 <= FETCH_Instr_non_pipelined_a0;

         // Staging of $pc_inc.
         always_ff @(posedge clk) FETCH_Instr_pc_inc_a1[31:2] <= FETCH_Instr_pc_inc_a0[31:2];

         // Staging of $replay.
         always_ff @(posedge clk) FETCH_Instr_replay_a1 <= FETCH_Instr_replay_a0;

         // Staging of $reset.
         always_ff @(posedge clk) FETCH_Instr_reset_a0 <= FETCH_Instr_reset_n1;

         // Staging of $second_issue.
         always_ff @(posedge clk) FETCH_Instr_second_issue_a1 <= FETCH_Instr_second_issue_a0;

         // Staging of $stall_cnt.
         always_ff @(posedge clk) FETCH_Instr_stall_cnt_a1[5:0] <= FETCH_Instr_stall_cnt_a0[5:0];

         // Staging of $stall_cnt_upper_div.
         always_ff @(posedge clk) FETCH_Instr_stall_cnt_upper_div_a1 <= FETCH_Instr_stall_cnt_upper_div_a0;

         // Staging of $stall_cnt_upper_mul.
         always_ff @(posedge clk) FETCH_Instr_stall_cnt_upper_mul_a1 <= FETCH_Instr_stall_cnt_upper_mul_a0;

         // Staging of $trap_target.
         always_ff @(posedge clk) FETCH_Instr_trap_target_a1[31:2] <= FETCH_Instr_trap_target_a0[31:2];

         // Staging of $trigger_next_pc_div_mul_second_issue.
         always_ff @(posedge clk) FETCH_Instr_trigger_next_pc_div_mul_second_issue_a1 <= FETCH_Instr_trigger_next_pc_div_mul_second_issue_a0;


         //
         // Scope: /hold_inst
         //

            // Staging of $dest_reg.
            always_ff @(posedge clk) FETCH_Instr_HoldInst_dest_reg_a1[4:0] <= FETCH_Instr_HoldInst_dest_reg_a0[4:0];

            // Staging of $pc.
            always_ff @(posedge clk) FETCH_Instr_HoldInst_pc_a1[31:2] <= FETCH_Instr_HoldInst_pc_a0[31:2];


            //
            // Scope: /src[2:1]
            //
            for (src = 1; src <= 2; src++) begin : L1gen_FETCH_Instr_HoldInst_Src
               // Staging of $dummy.
               always_ff @(posedge clk) L1_FETCH_Instr_HoldInst_Src[src].L1_dummy_a1 <= L1_FETCH_Instr_HoldInst_Src[src].L1_dummy_a0;

            end


         //
         // Scope: /orig_load_inst
         //

            // Staging of an unconditioned version of a condition signal.
            assign FETCH_Instr_OrigLoadInst_g0_spec_ld_cond_a0 = FETCH_Instr_OrigLoadInst_spec_ld_cond_a0 && FETCH_Instr_second_issue_ld_a0;



         //
         // Scope: /regs[31:1]
         //
         for (regs = 1; regs <= 31; regs++) begin : L1gen_FETCH_Instr_Regs
            // Staging of $pending.
            always_ff @(posedge clk) FETCH_Instr_Regs_pending_a0[regs] <= FETCH_Instr_Regs_pending_n1[regs];

         end



   //
   // Scope: |mem
   //


      //
      // Scope: /data
      //

         // Staging of $addr.
         always_ff @(posedge clk) MEM_Data_addr_a1[1:0] <= MEM_Data_addr_a0[1:0];

         // Staging of $dest_reg.
         always_ff @(posedge clk) MEM_Data_dest_reg_a1[4:0] <= MEM_Data_dest_reg_a0[4:0];

         // Staging of $ld_st_half.
         always_ff @(posedge clk) MEM_Data_ld_st_half_a1 <= MEM_Data_ld_st_half_a0;

         // Staging of $ld_st_word.
         always_ff @(posedge clk) MEM_Data_ld_st_word_a1 <= MEM_Data_ld_st_word_a0;

         // Staging of $pc.
         always_ff @(posedge clk) MEM_Data_pc_a1[31:2] <= MEM_Data_pc_a0[31:2];

         // Staging of $raw_funct3.
         always_ff @(posedge clk) MEM_Data_raw_funct3_a1[2] <= MEM_Data_raw_funct3_a0[2];

         // Staging of $spec_ld.
         always_ff @(posedge clk) MEM_Data_spec_ld_a1 <= MEM_Data_spec_ld_a0;

         // Staging of $valid_ld.
         always_ff @(posedge clk) MEM_Data_valid_ld_a1 <= MEM_Data_valid_ld_a0;


         //
         // Scope: /src[2:1]
         //
         for (src = 1; src <= 2; src++) begin : L1gen_MEM_Data_Src
            // Staging of $dummy.
            always_ff @(posedge clk) L1_MEM_Data_Src[src].L1_dummy_a1 <= L1_MEM_Data_Src[src].L1_dummy_a0;

         end





//
// Gated clocks.
//



   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         clk_gate gen_clkP_FETCH_Instr_valid_exe_a1(clkP_FETCH_Instr_valid_exe_a1, clk, 1'b1, FETCH_Instr_valid_exe_a0, 1'b0);






//
// Debug Signals
//

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |fetch
      //
      if (1) begin : \|fetch 

         //
         // Scope: /instr
         //
         if (1) begin : \/instr 
            logic [7:0] \//@-2$Cnt ;
            assign \//@-2$Cnt = FETCH_Instr_Cnt_n2;
            logic [1+1:0] \//@-1$GoodPathMask ;
            assign \//@-1$GoodPathMask = FETCH_Instr_GoodPathMask_n1;
            logic  \//@-1$NoFetch ;
            assign \//@-1$NoFetch = FETCH_Instr_NoFetch_n1;
            logic [31:2] \//@-1$Pc ;
            assign \//@-1$Pc = FETCH_Instr_Pc_n1;
            logic [30-1:0] \//@-1$RemainingCyclesWithinTimeUnit ;
            assign \//@-1$RemainingCyclesWithinTimeUnit = FETCH_Instr_RemainingCyclesWithinTimeUnit_n1;
            logic  \//@0$abort ;
            assign \//@0$abort = FETCH_Instr_abort_a0;
            logic  \//@0$aborting_isa_trap ;
            assign \//@0$aborting_isa_trap = FETCH_Instr_aborting_isa_trap_a0;
            logic  \//@0$aborting_trap ;
            assign \//@0$aborting_trap = FETCH_Instr_aborting_trap_a0;
            logic [31:0] \//?$valid_exe@0$add_rslt ;
            assign \//?$valid_exe@0$add_rslt = FETCH_Instr_add_rslt_a0;
            logic [31:0] \//?$valid_exe@0$add_sub_rslt ;
            assign \//?$valid_exe@0$add_sub_rslt = FETCH_Instr_add_sub_rslt_a0;
            logic [31:0] \//?$valid_exe@0$addi_rslt ;
            assign \//?$valid_exe@0$addi_rslt = FETCH_Instr_addi_rslt_a0;
            logic [31:0] \//?$ld_st_cond@0$addr ;
            assign \//?$ld_st_cond@0$addr = FETCH_Instr_addr_a0;
            logic [31:0] \//?$valid_exe@0$and_rslt ;
            assign \//?$valid_exe@0$and_rslt = FETCH_Instr_and_rslt_a0;
            logic [31:0] \//?$valid_exe@0$andi_rslt ;
            assign \//?$valid_exe@0$andi_rslt = FETCH_Instr_andi_rslt_a0;
            logic [31:0] \//?$valid_exe@0$auipc_rslt ;
            assign \//?$valid_exe@0$auipc_rslt = FETCH_Instr_auipc_rslt_a0;
            logic  \//@0$branch ;
            assign \//@0$branch = FETCH_Instr_branch_a0;
            logic [31:2] \//?$valid_decode_branch@0$branch_redir_pc ;
            assign \//?$valid_decode_branch@0$branch_redir_pc = FETCH_Instr_branch_redir_pc_a0;
            logic [31:2] \//?$valid_decode_branch@0$branch_target ;
            assign \//?$valid_decode_branch@0$branch_target = FETCH_Instr_branch_target_a0;
            logic  \//?$valid_exe@0$clk ;
            assign \//?$valid_exe@0$clk = FETCH_Instr_clk_a0;
            logic  \//@0$commit ;
            assign \//@0$commit = FETCH_Instr_commit_a0;
            logic  \//?$valid_decode@0$conditional_branch ;
            assign \//?$valid_decode@0$conditional_branch = FETCH_Instr_conditional_branch_a0;
            logic [31:0] \//@-1$csr_cycle ;
            assign \//@-1$csr_cycle = FETCH_Instr_csr_cycle_n1;
            logic  \//@0$csr_cycle_hw_wr ;
            assign \//@0$csr_cycle_hw_wr = FETCH_Instr_csr_cycle_hw_wr_a0;
            logic [31:0] \//@0$csr_cycle_hw_wr_en_mask ;
            assign \//@0$csr_cycle_hw_wr_en_mask = FETCH_Instr_csr_cycle_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_cycle_hw_wr_mask ;
            assign \//@0$csr_cycle_hw_wr_mask = FETCH_Instr_csr_cycle_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_cycle_hw_wr_value ;
            assign \//@0$csr_cycle_hw_wr_value = FETCH_Instr_csr_cycle_hw_wr_value_a0;
            logic [31:0] \//@0$csr_cycle_masked_wr_value ;
            assign \//@0$csr_cycle_masked_wr_value = FETCH_Instr_csr_cycle_masked_wr_value_a0;
            logic [31:0] \//@-1$csr_cycleh ;
            assign \//@-1$csr_cycleh = FETCH_Instr_csr_cycleh_n1;
            logic  \//@0$csr_cycleh_hw_wr ;
            assign \//@0$csr_cycleh_hw_wr = FETCH_Instr_csr_cycleh_hw_wr_a0;
            logic [31:0] \//@0$csr_cycleh_hw_wr_en_mask ;
            assign \//@0$csr_cycleh_hw_wr_en_mask = FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_cycleh_hw_wr_mask ;
            assign \//@0$csr_cycleh_hw_wr_mask = FETCH_Instr_csr_cycleh_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_cycleh_hw_wr_value ;
            assign \//@0$csr_cycleh_hw_wr_value = FETCH_Instr_csr_cycleh_hw_wr_value_a0;
            logic [31:0] \//@0$csr_cycleh_masked_wr_value ;
            assign \//@0$csr_cycleh_masked_wr_value = FETCH_Instr_csr_cycleh_masked_wr_value_a0;
            logic [31:0] \//@-1$csr_instret ;
            assign \//@-1$csr_instret = FETCH_Instr_csr_instret_n1;
            logic  \//@0$csr_instret_hw_wr ;
            assign \//@0$csr_instret_hw_wr = FETCH_Instr_csr_instret_hw_wr_a0;
            logic [31:0] \//@0$csr_instret_hw_wr_en_mask ;
            assign \//@0$csr_instret_hw_wr_en_mask = FETCH_Instr_csr_instret_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_instret_hw_wr_mask ;
            assign \//@0$csr_instret_hw_wr_mask = FETCH_Instr_csr_instret_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_instret_hw_wr_value ;
            assign \//@0$csr_instret_hw_wr_value = FETCH_Instr_csr_instret_hw_wr_value_a0;
            logic [31:0] \//@0$csr_instret_masked_wr_value ;
            assign \//@0$csr_instret_masked_wr_value = FETCH_Instr_csr_instret_masked_wr_value_a0;
            logic [31:0] \//@-1$csr_instreth ;
            assign \//@-1$csr_instreth = FETCH_Instr_csr_instreth_n1;
            logic  \//@0$csr_instreth_hw_wr ;
            assign \//@0$csr_instreth_hw_wr = FETCH_Instr_csr_instreth_hw_wr_a0;
            logic [31:0] \//@0$csr_instreth_hw_wr_en_mask ;
            assign \//@0$csr_instreth_hw_wr_en_mask = FETCH_Instr_csr_instreth_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_instreth_hw_wr_mask ;
            assign \//@0$csr_instreth_hw_wr_mask = FETCH_Instr_csr_instreth_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_instreth_hw_wr_value ;
            assign \//@0$csr_instreth_hw_wr_value = FETCH_Instr_csr_instreth_hw_wr_value_a0;
            logic [31:0] \//@0$csr_instreth_masked_wr_value ;
            assign \//@0$csr_instreth_masked_wr_value = FETCH_Instr_csr_instreth_masked_wr_value_a0;
            logic [31:0] \//@-1$csr_time ;
            assign \//@-1$csr_time = FETCH_Instr_csr_time_n1;
            logic  \//@0$csr_time_hw_wr ;
            assign \//@0$csr_time_hw_wr = FETCH_Instr_csr_time_hw_wr_a0;
            logic [31:0] \//@0$csr_time_hw_wr_en_mask ;
            assign \//@0$csr_time_hw_wr_en_mask = FETCH_Instr_csr_time_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_time_hw_wr_mask ;
            assign \//@0$csr_time_hw_wr_mask = FETCH_Instr_csr_time_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_time_hw_wr_value ;
            assign \//@0$csr_time_hw_wr_value = FETCH_Instr_csr_time_hw_wr_value_a0;
            logic [31:0] \//@0$csr_time_masked_wr_value ;
            assign \//@0$csr_time_masked_wr_value = FETCH_Instr_csr_time_masked_wr_value_a0;
            logic [31:0] \//@-1$csr_timeh ;
            assign \//@-1$csr_timeh = FETCH_Instr_csr_timeh_n1;
            logic  \//@0$csr_timeh_hw_wr ;
            assign \//@0$csr_timeh_hw_wr = FETCH_Instr_csr_timeh_hw_wr_a0;
            logic [31:0] \//@0$csr_timeh_hw_wr_en_mask ;
            assign \//@0$csr_timeh_hw_wr_en_mask = FETCH_Instr_csr_timeh_hw_wr_en_mask_a0;
            logic [31:0] \//@0$csr_timeh_hw_wr_mask ;
            assign \//@0$csr_timeh_hw_wr_mask = FETCH_Instr_csr_timeh_hw_wr_mask_a0;
            logic [31:0] \//@0$csr_timeh_hw_wr_value ;
            assign \//@0$csr_timeh_hw_wr_value = FETCH_Instr_csr_timeh_hw_wr_value_a0;
            logic [31:0] \//@0$csr_timeh_masked_wr_value ;
            assign \//@0$csr_timeh_masked_wr_value = FETCH_Instr_csr_timeh_masked_wr_value_a0;
            logic  \//@0$csr_trap ;
            assign \//@0$csr_trap = FETCH_Instr_csr_trap_a0;
            logic [31:0] \//@0$csr_wr_value ;
            assign \//@0$csr_wr_value = FETCH_Instr_csr_wr_value_a0;
            logic [31:0] \//?$valid_exe@0$csrrc_rslt ;
            assign \//?$valid_exe@0$csrrc_rslt = FETCH_Instr_csrrc_rslt_a0;
            logic [31:0] \//?$valid_exe@0$csrrci_rslt ;
            assign \//?$valid_exe@0$csrrci_rslt = FETCH_Instr_csrrci_rslt_a0;
            logic [31:0] \//?$valid_exe@0$csrrs_rslt ;
            assign \//?$valid_exe@0$csrrs_rslt = FETCH_Instr_csrrs_rslt_a0;
            logic [31:0] \//?$valid_exe@0$csrrsi_rslt ;
            assign \//?$valid_exe@0$csrrsi_rslt = FETCH_Instr_csrrsi_rslt_a0;
            logic [31:0] \//?$valid_exe@0$csrrw_rslt ;
            assign \//?$valid_exe@0$csrrw_rslt = FETCH_Instr_csrrw_rslt_a0;
            logic [31:0] \//?$valid_exe@0$csrrwi_rslt ;
            assign \//?$valid_exe@0$csrrwi_rslt = FETCH_Instr_csrrwi_rslt_a0;
            logic  \//?$is_dest_condition@0$dest_pending ;
            assign \//?$is_dest_condition@0$dest_pending = FETCH_Instr_dest_pending_a0;
            logic [4:0] \//@0$dest_reg ;
            assign \//@0$dest_reg = FETCH_Instr_dest_reg_a0;
            logic  \//@0$dest_reg_valid ;
            assign \//@0$dest_reg_valid = FETCH_Instr_dest_reg_valid_a0;
            logic [31:0] \//?$valid_exe@0$div_in1 ;
            assign \//?$valid_exe@0$div_in1 = FETCH_Instr_div_in1_a0;
            logic [31:0] \//?$valid_exe@0$div_in2 ;
            assign \//?$valid_exe@0$div_in2 = FETCH_Instr_div_in2_a0;
            logic  \//?$valid_decode@0$div_mul ;
            assign \//?$valid_decode@0$div_mul = FETCH_Instr_div_mul_a0;
            logic [31:0] \//?$valid_exe@0$div_rslt ;
            assign \//?$valid_exe@0$div_rslt = FETCH_Instr_div_rslt_a0;
            logic  \//@0$div_stall ;
            assign \//@0$div_stall = FETCH_Instr_div_stall_a0;
            logic  \//@0$divblk_valid ;
            assign \//@0$divblk_valid = FETCH_Instr_divblk_valid_a0;
            logic [31:0] \///@0$divblock_rslt ;
            assign \///@0$divblock_rslt = FETCH_Instr_divblock_rslt_a0;
            logic  \//?$valid_decode@0$divtype_instr ;
            assign \//?$valid_decode@0$divtype_instr = FETCH_Instr_divtype_instr_a0;
            logic [31:0] \//?$valid_exe@0$divu_rslt ;
            assign \//?$valid_exe@0$divu_rslt = FETCH_Instr_divu_rslt_a0;
            logic  \//?$valid_exe@0$equal ;
            assign \//?$valid_exe@0$equal = FETCH_Instr_equal_a0;
            logic  \//@0$failed ;
            assign \//@0$failed = FETCH_Instr_failed_a0;
            logic  \//@0$fetch ;
            assign \//@0$fetch = FETCH_Instr_fetch_a0;
            logic  \//@0$first_issue ;
            assign \//@0$first_issue = FETCH_Instr_first_issue_a0;
            logic [63:0] \//@0$full_csr_cycle_hw_wr_value ;
            assign \//@0$full_csr_cycle_hw_wr_value = FETCH_Instr_full_csr_cycle_hw_wr_value_a0;
            logic [63:0] \//@0$full_csr_instret_hw_wr_value ;
            assign \//@0$full_csr_instret_hw_wr_value = FETCH_Instr_full_csr_instret_hw_wr_value_a0;
            logic [63:0] \//@0$full_csr_time_hw_wr_value ;
            assign \//@0$full_csr_time_hw_wr_value = FETCH_Instr_full_csr_time_hw_wr_value_a0;
            logic  \//@0$good_path ;
            assign \//@0$good_path = FETCH_Instr_good_path_a0;
            logic  \//?$valid_decode@0$illegal ;
            assign \//?$valid_decode@0$illegal = FETCH_Instr_illegal_a0;
            logic  \//?$valid_decode@0$illegal_itype_with_funct7 ;
            assign \//?$valid_decode@0$illegal_itype_with_funct7 = FETCH_Instr_illegal_itype_with_funct7_a0;
            logic  \//@0$imm_valid ;
            assign \//@0$imm_valid = FETCH_Instr_imm_valid_a0;
            logic [31:0] \//@0$imm_value ;
            assign \//@0$imm_value = FETCH_Instr_imm_value_a0;
            logic  \//@0$indirect_jump ;
            assign \//@0$indirect_jump = FETCH_Instr_indirect_jump_a0;
            logic [31:0] \//?$indirect_jump@0$indirect_jump_full_target ;
            assign \//?$indirect_jump@0$indirect_jump_full_target = FETCH_Instr_indirect_jump_full_target_a0;
            logic [31:2] \//?$indirect_jump@0$indirect_jump_target ;
            assign \//?$indirect_jump@0$indirect_jump_target = FETCH_Instr_indirect_jump_target_a0;
            logic [3:0] \//?$valid_exe@0$instr_type_div ;
            assign \//?$valid_exe@0$instr_type_div = FETCH_Instr_instr_type_div_a0;
            logic [3:0] \//?$valid_exe@0$instr_type_mul ;
            assign \//?$valid_exe@0$instr_type_mul = FETCH_Instr_instr_type_mul_a0;
            logic  \//?$valid_decode@0$is___type ;
            assign \//?$valid_decode@0$is___type = FETCH_Instr_is___type_a0;
            logic  \//?$valid_decode@0$is_add_instr ;
            assign \//?$valid_decode@0$is_add_instr = FETCH_Instr_is_add_instr_a0;
            logic  \//?$valid_decode@0$is_addi_instr ;
            assign \//?$valid_decode@0$is_addi_instr = FETCH_Instr_is_addi_instr_a0;
            logic  \//?$valid_decode@0$is_and_instr ;
            assign \//?$valid_decode@0$is_and_instr = FETCH_Instr_is_and_instr_a0;
            logic  \//?$valid_decode@0$is_andi_instr ;
            assign \//?$valid_decode@0$is_andi_instr = FETCH_Instr_is_andi_instr_a0;
            logic  \//?$valid_decode@0$is_auipc_instr ;
            assign \//?$valid_decode@0$is_auipc_instr = FETCH_Instr_is_auipc_instr_a0;
            logic  \//?$valid_decode@0$is_b_type ;
            assign \//?$valid_decode@0$is_b_type = FETCH_Instr_is_b_type_a0;
            logic  \//?$valid_decode@0$is_beq_instr ;
            assign \//?$valid_decode@0$is_beq_instr = FETCH_Instr_is_beq_instr_a0;
            logic  \//?$valid_decode@0$is_bge_instr ;
            assign \//?$valid_decode@0$is_bge_instr = FETCH_Instr_is_bge_instr_a0;
            logic  \//?$valid_decode@0$is_bgeu_instr ;
            assign \//?$valid_decode@0$is_bgeu_instr = FETCH_Instr_is_bgeu_instr_a0;
            logic  \//?$valid_decode@0$is_blt_instr ;
            assign \//?$valid_decode@0$is_blt_instr = FETCH_Instr_is_blt_instr_a0;
            logic  \//?$valid_decode@0$is_bltu_instr ;
            assign \//?$valid_decode@0$is_bltu_instr = FETCH_Instr_is_bltu_instr_a0;
            logic  \//?$valid_decode@0$is_bne_instr ;
            assign \//?$valid_decode@0$is_bne_instr = FETCH_Instr_is_bne_instr_a0;
            logic  \//@0$is_csr_clear ;
            assign \//@0$is_csr_clear = FETCH_Instr_is_csr_clear_a0;
            logic  \//@0$is_csr_cycle ;
            assign \//@0$is_csr_cycle = FETCH_Instr_is_csr_cycle_a0;
            logic  \//@0$is_csr_cycleh ;
            assign \//@0$is_csr_cycleh = FETCH_Instr_is_csr_cycleh_a0;
            logic  \//@0$is_csr_instr ;
            assign \//@0$is_csr_instr = FETCH_Instr_is_csr_instr_a0;
            logic  \//@0$is_csr_instret ;
            assign \//@0$is_csr_instret = FETCH_Instr_is_csr_instret_a0;
            logic  \//@0$is_csr_instreth ;
            assign \//@0$is_csr_instreth = FETCH_Instr_is_csr_instreth_a0;
            logic  \//@0$is_csr_set ;
            assign \//@0$is_csr_set = FETCH_Instr_is_csr_set_a0;
            logic  \//@0$is_csr_time ;
            assign \//@0$is_csr_time = FETCH_Instr_is_csr_time_a0;
            logic  \//@0$is_csr_timeh ;
            assign \//@0$is_csr_timeh = FETCH_Instr_is_csr_timeh_a0;
            logic  \//@0$is_csr_write ;
            assign \//@0$is_csr_write = FETCH_Instr_is_csr_write_a0;
            logic  \//?$valid_decode@0$is_csrrc_instr ;
            assign \//?$valid_decode@0$is_csrrc_instr = FETCH_Instr_is_csrrc_instr_a0;
            logic  \//?$valid_decode@0$is_csrrci_instr ;
            assign \//?$valid_decode@0$is_csrrci_instr = FETCH_Instr_is_csrrci_instr_a0;
            logic  \//?$valid_decode@0$is_csrrs_instr ;
            assign \//?$valid_decode@0$is_csrrs_instr = FETCH_Instr_is_csrrs_instr_a0;
            logic  \//?$valid_decode@0$is_csrrsi_instr ;
            assign \//?$valid_decode@0$is_csrrsi_instr = FETCH_Instr_is_csrrsi_instr_a0;
            logic  \//?$valid_decode@0$is_csrrw_instr ;
            assign \//?$valid_decode@0$is_csrrw_instr = FETCH_Instr_is_csrrw_instr_a0;
            logic  \//?$valid_decode@0$is_csrrwi_instr ;
            assign \//?$valid_decode@0$is_csrrwi_instr = FETCH_Instr_is_csrrwi_instr_a0;
            logic  \//@0$is_dest_condition ;
            assign \//@0$is_dest_condition = FETCH_Instr_is_dest_condition_a0;
            logic  \//?$valid_decode@0$is_div_instr ;
            assign \//?$valid_decode@0$is_div_instr = FETCH_Instr_is_div_instr_a0;
            logic  \//?$valid_decode@0$is_divu_instr ;
            assign \//?$valid_decode@0$is_divu_instr = FETCH_Instr_is_divu_instr_a0;
            logic  \//?$valid_decode@0$is_i_type ;
            assign \//?$valid_decode@0$is_i_type = FETCH_Instr_is_i_type_a0;
            logic  \//?$valid_decode@0$is_j_type ;
            assign \//?$valid_decode@0$is_j_type = FETCH_Instr_is_j_type_a0;
            logic  \//?$valid_decode@0$is_jal_instr ;
            assign \//?$valid_decode@0$is_jal_instr = FETCH_Instr_is_jal_instr_a0;
            logic  \//?$valid_decode@0$is_jalr_instr ;
            assign \//?$valid_decode@0$is_jalr_instr = FETCH_Instr_is_jalr_instr_a0;
            logic  \//?$valid_decode@0$is_lb_instr ;
            assign \//?$valid_decode@0$is_lb_instr = FETCH_Instr_is_lb_instr_a0;
            logic  \//?$valid_decode@0$is_lbu_instr ;
            assign \//?$valid_decode@0$is_lbu_instr = FETCH_Instr_is_lbu_instr_a0;
            logic  \//?$valid_decode@0$is_lh_instr ;
            assign \//?$valid_decode@0$is_lh_instr = FETCH_Instr_is_lh_instr_a0;
            logic  \//?$valid_decode@0$is_lhu_instr ;
            assign \//?$valid_decode@0$is_lhu_instr = FETCH_Instr_is_lhu_instr_a0;
            logic  \//?$valid_decode@0$is_lui_instr ;
            assign \//?$valid_decode@0$is_lui_instr = FETCH_Instr_is_lui_instr_a0;
            logic  \//?$valid_decode@0$is_lw_instr ;
            assign \//?$valid_decode@0$is_lw_instr = FETCH_Instr_is_lw_instr_a0;
            logic  \//?$valid_decode@0$is_mul_instr ;
            assign \//?$valid_decode@0$is_mul_instr = FETCH_Instr_is_mul_instr_a0;
            logic  \//?$valid_decode@0$is_mulh_instr ;
            assign \//?$valid_decode@0$is_mulh_instr = FETCH_Instr_is_mulh_instr_a0;
            logic  \//?$valid_decode@0$is_mulhsu_instr ;
            assign \//?$valid_decode@0$is_mulhsu_instr = FETCH_Instr_is_mulhsu_instr_a0;
            logic  \//?$valid_decode@0$is_mulhu_instr ;
            assign \//?$valid_decode@0$is_mulhu_instr = FETCH_Instr_is_mulhu_instr_a0;
            logic  \//?$valid_decode@0$is_or_instr ;
            assign \//?$valid_decode@0$is_or_instr = FETCH_Instr_is_or_instr_a0;
            logic  \//?$valid_decode@0$is_ori_instr ;
            assign \//?$valid_decode@0$is_ori_instr = FETCH_Instr_is_ori_instr_a0;
            logic  \//?$valid_decode@0$is_r2_type ;
            assign \//?$valid_decode@0$is_r2_type = FETCH_Instr_is_r2_type_a0;
            logic  \//?$valid_decode@0$is_r4_type ;
            assign \//?$valid_decode@0$is_r4_type = FETCH_Instr_is_r4_type_a0;
            logic  \//?$valid_decode@0$is_r_type ;
            assign \//?$valid_decode@0$is_r_type = FETCH_Instr_is_r_type_a0;
            logic  \//?$valid_decode@0$is_rem_instr ;
            assign \//?$valid_decode@0$is_rem_instr = FETCH_Instr_is_rem_instr_a0;
            logic  \//?$valid_decode@0$is_remu_instr ;
            assign \//?$valid_decode@0$is_remu_instr = FETCH_Instr_is_remu_instr_a0;
            logic  \//?$valid_decode@0$is_s_type ;
            assign \//?$valid_decode@0$is_s_type = FETCH_Instr_is_s_type_a0;
            logic  \//?$valid_decode@0$is_sb_instr ;
            assign \//?$valid_decode@0$is_sb_instr = FETCH_Instr_is_sb_instr_a0;
            logic  \//?$valid_decode@0$is_sh_instr ;
            assign \//?$valid_decode@0$is_sh_instr = FETCH_Instr_is_sh_instr_a0;
            logic  \//?$valid_decode@0$is_sll_instr ;
            assign \//?$valid_decode@0$is_sll_instr = FETCH_Instr_is_sll_instr_a0;
            logic  \//?$valid_decode@0$is_slli_instr ;
            assign \//?$valid_decode@0$is_slli_instr = FETCH_Instr_is_slli_instr_a0;
            logic  \//?$valid_decode@0$is_slt_instr ;
            assign \//?$valid_decode@0$is_slt_instr = FETCH_Instr_is_slt_instr_a0;
            logic  \//?$valid_decode@0$is_slti_instr ;
            assign \//?$valid_decode@0$is_slti_instr = FETCH_Instr_is_slti_instr_a0;
            logic  \//?$valid_decode@0$is_sltiu_instr ;
            assign \//?$valid_decode@0$is_sltiu_instr = FETCH_Instr_is_sltiu_instr_a0;
            logic  \//?$valid_decode@0$is_sltu_instr ;
            assign \//?$valid_decode@0$is_sltu_instr = FETCH_Instr_is_sltu_instr_a0;
            logic  \//?$valid_decode@0$is_sra_instr ;
            assign \//?$valid_decode@0$is_sra_instr = FETCH_Instr_is_sra_instr_a0;
            logic  \//?$valid_decode@0$is_srai_instr ;
            assign \//?$valid_decode@0$is_srai_instr = FETCH_Instr_is_srai_instr_a0;
            logic  \//?$valid_decode@0$is_srl_instr ;
            assign \//?$valid_decode@0$is_srl_instr = FETCH_Instr_is_srl_instr_a0;
            logic  \//?$valid_decode@0$is_srli_instr ;
            assign \//?$valid_decode@0$is_srli_instr = FETCH_Instr_is_srli_instr_a0;
            logic  \//?$valid_decode@0$is_srli_srai_instr ;
            assign \//?$valid_decode@0$is_srli_srai_instr = FETCH_Instr_is_srli_srai_instr_a0;
            logic  \//?$valid_decode@0$is_sub_instr ;
            assign \//?$valid_decode@0$is_sub_instr = FETCH_Instr_is_sub_instr_a0;
            logic  \//?$valid_decode@0$is_sw_instr ;
            assign \//?$valid_decode@0$is_sw_instr = FETCH_Instr_is_sw_instr_a0;
            logic  \//?$valid_decode@0$is_u_type ;
            assign \//?$valid_decode@0$is_u_type = FETCH_Instr_is_u_type_a0;
            logic  \//?$valid_decode@0$is_xor_instr ;
            assign \//?$valid_decode@0$is_xor_instr = FETCH_Instr_is_xor_instr_a0;
            logic  \//?$valid_decode@0$is_xori_instr ;
            assign \//?$valid_decode@0$is_xori_instr = FETCH_Instr_is_xori_instr_a0;
            logic [31:0] \//?$valid_exe@0$jal_rslt ;
            assign \//?$valid_exe@0$jal_rslt = FETCH_Instr_jal_rslt_a0;
            logic [31:0] \//?$valid_exe@0$jalr_rslt ;
            assign \//?$valid_exe@0$jalr_rslt = FETCH_Instr_jalr_rslt_a0;
            logic  \//@0$jump ;
            assign \//@0$jump = FETCH_Instr_jump_a0;
            logic [31:2] \//?$jump@0$jump_target ;
            assign \//?$jump@0$jump_target = FETCH_Instr_jump_target_a0;
            logic [31:0] \//?$valid_exe@0$lb_rslt ;
            assign \//?$valid_exe@0$lb_rslt = FETCH_Instr_lb_rslt_a0;
            logic [31:0] \//?$valid_exe@0$lbu_rslt ;
            assign \//?$valid_exe@0$lbu_rslt = FETCH_Instr_lbu_rslt_a0;
            logic  \//?$valid_decode@0$ld ;
            assign \//?$valid_decode@0$ld = FETCH_Instr_ld_a0;
            logic [31:0] \//@0$ld_data ;
            assign \//@0$ld_data = FETCH_Instr_ld_data_a0;
            logic  \//?$valid_decode@0$ld_st ;
            assign \//?$valid_decode@0$ld_st = FETCH_Instr_ld_st_a0;
            logic  \//@0$ld_st_cond ;
            assign \//@0$ld_st_cond = FETCH_Instr_ld_st_cond_a0;
            logic  \//?$valid_decode@0$ld_st_half ;
            assign \//?$valid_decode@0$ld_st_half = FETCH_Instr_ld_st_half_a0;
            logic  \//?$valid_decode@0$ld_st_word ;
            assign \//?$valid_decode@0$ld_st_word = FETCH_Instr_ld_st_word_a0;
            logic [31:0] \//?$valid_exe@0$lh_rslt ;
            assign \//?$valid_exe@0$lh_rslt = FETCH_Instr_lh_rslt_a0;
            logic [31:0] \//?$valid_exe@0$lhu_rslt ;
            assign \//?$valid_exe@0$lhu_rslt = FETCH_Instr_lhu_rslt_a0;
            logic [31:0] \//?$valid_exe@0$lui_rslt ;
            assign \//?$valid_exe@0$lui_rslt = FETCH_Instr_lui_rslt_a0;
            logic [31:0] \//?$valid_exe@0$lw_rslt ;
            assign \//?$valid_exe@0$lw_rslt = FETCH_Instr_lw_rslt_a0;
            logic  \//?$indirect_jump@0$misaligned_indirect_jump_target ;
            assign \//?$indirect_jump@0$misaligned_indirect_jump_target = FETCH_Instr_misaligned_indirect_jump_target_a0;
            logic  \//?$jump@0$misaligned_jump_target ;
            assign \//?$jump@0$misaligned_jump_target = FETCH_Instr_misaligned_jump_target_a0;
            logic  \//?$valid_decode_branch@0$misaligned_pc ;
            assign \//?$valid_decode_branch@0$misaligned_pc = FETCH_Instr_misaligned_pc_a0;
            logic  \//@0$mispred_branch ;
            assign \//@0$mispred_branch = FETCH_Instr_mispred_branch_a0;
            logic [10*8-1:0] \//?$valid_decode@0$mnemonic ;
            assign \//?$valid_decode@0$mnemonic = FETCH_Instr_mnemonic_a0;
            logic [31:0] \//?$valid_exe@0$mul_in1 ;
            assign \//?$valid_exe@0$mul_in1 = FETCH_Instr_mul_in1_a0;
            logic [31:0] \//?$valid_exe@0$mul_in2 ;
            assign \//?$valid_exe@0$mul_in2 = FETCH_Instr_mul_in2_a0;
            logic [31:0] \//?$valid_exe@0$mul_rslt ;
            assign \//?$valid_exe@0$mul_rslt = FETCH_Instr_mul_rslt_a0;
            logic  \//@0$mul_stall ;
            assign \//@0$mul_stall = FETCH_Instr_mul_stall_a0;
            logic  \//@0$mulblk_valid ;
            assign \//@0$mulblk_valid = FETCH_Instr_mulblk_valid_a0;
            logic [31:0] \///@0$mulblock_rslt ;
            assign \///@0$mulblock_rslt = FETCH_Instr_mulblock_rslt_a0;
            logic [31:0] \//?$valid_exe@0$mulh_rslt ;
            assign \//?$valid_exe@0$mulh_rslt = FETCH_Instr_mulh_rslt_a0;
            logic [31:0] \//?$valid_exe@0$mulhsu_rslt ;
            assign \//?$valid_exe@0$mulhsu_rslt = FETCH_Instr_mulhsu_rslt_a0;
            logic [31:0] \//?$valid_exe@0$mulhu_rslt ;
            assign \//?$valid_exe@0$mulhu_rslt = FETCH_Instr_mulhu_rslt_a0;
            logic  \//?$valid_decode@0$multype_instr ;
            assign \//?$valid_decode@0$multype_instr = FETCH_Instr_multype_instr_a0;
            logic [1+1:0] \//@0$next_good_path_mask ;
            assign \//@0$next_good_path_mask = FETCH_Instr_next_good_path_mask_a0;
            logic  \//@0$next_no_fetch ;
            assign \//@0$next_no_fetch = FETCH_Instr_next_no_fetch_a0;
            logic [31:2] \//@0$next_pc ;
            assign \//@0$next_pc = FETCH_Instr_next_pc_a0;
            logic  \//@0$non_aborting_isa_trap ;
            assign \//@0$non_aborting_isa_trap = FETCH_Instr_non_aborting_isa_trap_a0;
            logic  \//@0$non_aborting_trap ;
            assign \//@0$non_aborting_trap = FETCH_Instr_non_aborting_trap_a0;
            logic  \//@0$non_pipelined ;
            assign \//@0$non_pipelined = FETCH_Instr_non_pipelined_a0;
            logic [31:0] \//?$valid_exe@0$or_rslt ;
            assign \//?$valid_exe@0$or_rslt = FETCH_Instr_or_rslt_a0;
            logic [31:0] \//?$valid_exe@0$ori_rslt ;
            assign \//?$valid_exe@0$ori_rslt = FETCH_Instr_ori_rslt_a0;
            logic  \//@0$passed ;
            assign \//@0$passed = FETCH_Instr_passed_a0;
            logic [31:2] \//@0$pc ;
            assign \//@0$pc = FETCH_Instr_pc_a0;
            logic [31:2] \//@0$pc_inc ;
            assign \//@0$pc_inc = FETCH_Instr_pc_inc_a0;
            logic  \//@0$pending_replay ;
            assign \//@0$pending_replay = FETCH_Instr_pending_replay_a0;
            logic  \//@0$pred_taken ;
            assign \//@0$pred_taken = FETCH_Instr_pred_taken_a0;
            logic [31:0] \//?$fetch@0$raw ;
            assign \//?$fetch@0$raw = FETCH_Instr_raw_a0;
            logic  \//?$valid_decode@0$raw_aq ;
            assign \//?$valid_decode@0$raw_aq = FETCH_Instr_raw_aq_a0;
            logic [31:0] \//?$valid_decode@0$raw_b_imm ;
            assign \//?$valid_decode@0$raw_b_imm = FETCH_Instr_raw_b_imm_a0;
            logic [2:0] \//?$valid_decode@0$raw_funct3 ;
            assign \//?$valid_decode@0$raw_funct3 = FETCH_Instr_raw_funct3_a0;
            logic [6:0] \//?$valid_decode@0$raw_funct7 ;
            assign \//?$valid_decode@0$raw_funct7 = FETCH_Instr_raw_funct7_a0;
            logic [31:0] \//?$valid_decode@0$raw_i_imm ;
            assign \//?$valid_decode@0$raw_i_imm = FETCH_Instr_raw_i_imm_a0;
            logic [31:0] \//?$valid_decode@0$raw_j_imm ;
            assign \//?$valid_decode@0$raw_j_imm = FETCH_Instr_raw_j_imm_a0;
            logic [1:0] \//?$valid_decode@0$raw_op2 ;
            assign \//?$valid_decode@0$raw_op2 = FETCH_Instr_raw_op2_a0;
            logic [4:0] \//?$valid_decode@0$raw_op5 ;
            assign \//?$valid_decode@0$raw_op5 = FETCH_Instr_raw_op5_a0;
            logic [4:0] \//?$valid_decode@0$raw_rd ;
            assign \//?$valid_decode@0$raw_rd = FETCH_Instr_raw_rd_a0;
            logic  \//?$valid_decode@0$raw_rl ;
            assign \//?$valid_decode@0$raw_rl = FETCH_Instr_raw_rl_a0;
            logic [2:0] \//?$valid_decode@0$raw_rm ;
            assign \//?$valid_decode@0$raw_rm = FETCH_Instr_raw_rm_a0;
            logic [4:0] \//?$valid_decode@0$raw_rs1 ;
            assign \//?$valid_decode@0$raw_rs1 = FETCH_Instr_raw_rs1_a0;
            logic [4:0] \//?$valid_decode@0$raw_rs2 ;
            assign \//?$valid_decode@0$raw_rs2 = FETCH_Instr_raw_rs2_a0;
            logic [4:0] \//?$valid_decode@0$raw_rs3 ;
            assign \//?$valid_decode@0$raw_rs3 = FETCH_Instr_raw_rs3_a0;
            logic [31:0] \//?$valid_decode@0$raw_s_imm ;
            assign \//?$valid_decode@0$raw_s_imm = FETCH_Instr_raw_s_imm_a0;
            logic [6:0] \//?$valid_decode@0$raw_shamt ;
            assign \//?$valid_decode@0$raw_shamt = FETCH_Instr_raw_shamt_a0;
            logic [31:0] \//?$valid_decode@0$raw_u_imm ;
            assign \//?$valid_decode@0$raw_u_imm = FETCH_Instr_raw_u_imm_a0;
            logic  \///@0$readyd ;
            assign \///@0$readyd = FETCH_Instr_readyd_a0;
            logic  \///@0$readym ;
            assign \///@0$readym = FETCH_Instr_readym_a0;
            logic  \//@0$reg_wr_pending ;
            assign \//@0$reg_wr_pending = FETCH_Instr_reg_wr_pending_a0;
            logic [31:0] \//?$valid_exe@0$rem_rslt ;
            assign \//?$valid_exe@0$rem_rslt = FETCH_Instr_rem_rslt_a0;
            logic [31:0] \//?$valid_exe@0$remu_rslt ;
            assign \//?$valid_exe@0$remu_rslt = FETCH_Instr_remu_rslt_a0;
            logic  \//@0$replay ;
            assign \//@0$replay = FETCH_Instr_replay_a0;
            logic  \//@0$replay_trap ;
            assign \//@0$replay_trap = FETCH_Instr_replay_trap_a0;
            logic  \//@-1$reset ;
            assign \//@-1$reset = FETCH_Instr_reset_n1;
            logic  \//?$valid_exe@0$resetn ;
            assign \//?$valid_exe@0$resetn = FETCH_Instr_resetn_a0;
            logic [31:0] \//@0$rslt ;
            assign \//@0$rslt = FETCH_Instr_rslt_a0;
            logic  \//@0$second_issue ;
            assign \//@0$second_issue = FETCH_Instr_second_issue_a0;
            logic  \//@0$second_issue_div_mul ;
            assign \//@0$second_issue_div_mul = FETCH_Instr_second_issue_div_mul_a0;
            logic  \//@0$second_issue_ld ;
            assign \//@0$second_issue_ld = FETCH_Instr_second_issue_ld_a0;
            logic [31:0] \//?$valid_exe@0$sll_rslt ;
            assign \//?$valid_exe@0$sll_rslt = FETCH_Instr_sll_rslt_a0;
            logic [31:0] \//?$valid_exe@0$slli_rslt ;
            assign \//?$valid_exe@0$slli_rslt = FETCH_Instr_slli_rslt_a0;
            logic [31:0] \//?$valid_exe@0$slt_rslt ;
            assign \//?$valid_exe@0$slt_rslt = FETCH_Instr_slt_rslt_a0;
            logic [31:0] \//?$valid_exe@0$slti_rslt ;
            assign \//?$valid_exe@0$slti_rslt = FETCH_Instr_slti_rslt_a0;
            logic [31:0] \//?$valid_exe@0$sltiu_rslt ;
            assign \//?$valid_exe@0$sltiu_rslt = FETCH_Instr_sltiu_rslt_a0;
            logic [31:0] \//?$valid_exe@0$sltu_rslt ;
            assign \//?$valid_exe@0$sltu_rslt = FETCH_Instr_sltu_rslt_a0;
            logic  \//@-1$soft_reset ;
            assign \//@-1$soft_reset = FETCH_Instr_soft_reset_n1;
            logic  \//@0$spec_ld ;
            assign \//@0$spec_ld = FETCH_Instr_spec_ld_a0;
            logic [31:0] \//?$valid_exe@0$sra_rslt ;
            assign \//?$valid_exe@0$sra_rslt = FETCH_Instr_sra_rslt_a0;
            logic [31:0] \//?$valid_exe@0$srai_intermediate_rslt ;
            assign \//?$valid_exe@0$srai_intermediate_rslt = FETCH_Instr_srai_intermediate_rslt_a0;
            logic [31:0] \//?$valid_exe@0$srai_rslt ;
            assign \//?$valid_exe@0$srai_rslt = FETCH_Instr_srai_rslt_a0;
            logic [31:0] \//?$valid_exe@0$srl_rslt ;
            assign \//?$valid_exe@0$srl_rslt = FETCH_Instr_srl_rslt_a0;
            logic [31:0] \//?$valid_exe@0$srli_intermediate_rslt ;
            assign \//?$valid_exe@0$srli_intermediate_rslt = FETCH_Instr_srli_intermediate_rslt_a0;
            logic [31:0] \//?$valid_exe@0$srli_rslt ;
            assign \//?$valid_exe@0$srli_rslt = FETCH_Instr_srli_rslt_a0;
            logic  \//?$valid_decode@0$st ;
            assign \//?$valid_decode@0$st = FETCH_Instr_st_a0;
            logic  \//@0$st_cond ;
            assign \//@0$st_cond = FETCH_Instr_st_cond_a0;
            logic [3:0] \//?$st_cond@0$st_mask ;
            assign \//?$st_cond@0$st_mask = FETCH_Instr_st_mask_a0;
            logic [31:0] \//?$st_cond@0$st_reg_value ;
            assign \//?$st_cond@0$st_reg_value = FETCH_Instr_st_reg_value_a0;
            logic [31:0] \//?$st_cond@0$st_value ;
            assign \//?$st_cond@0$st_value = FETCH_Instr_st_value_a0;
            logic [5:0] \//@0$stall_cnt ;
            assign \//@0$stall_cnt = FETCH_Instr_stall_cnt_a0;
            logic  \//@0$stall_cnt_upper_div ;
            assign \//@0$stall_cnt_upper_div = FETCH_Instr_stall_cnt_upper_div_a0;
            logic  \//@0$stall_cnt_upper_mul ;
            assign \//@0$stall_cnt_upper_mul = FETCH_Instr_stall_cnt_upper_mul_a0;
            logic [31:0] \//?$valid_exe@0$sub_rslt ;
            assign \//?$valid_exe@0$sub_rslt = FETCH_Instr_sub_rslt_a0;
            logic  \//?$branch@0$taken ;
            assign \//?$branch@0$taken = FETCH_Instr_taken_a0;
            logic  \//@0$time_unit_expires ;
            assign \//@0$time_unit_expires = FETCH_Instr_time_unit_expires_a0;
            logic [31:2] \//@0$trap_target ;
            assign \//@0$trap_target = FETCH_Instr_trap_target_a0;
            logic  \//@0$trigger_next_pc_div_mul_second_issue ;
            assign \//@0$trigger_next_pc_div_mul_second_issue = FETCH_Instr_trigger_next_pc_div_mul_second_issue_a0;
            logic  \//?$valid_exe@0$unnatural_addr_trap ;
            assign \//?$valid_exe@0$unnatural_addr_trap = FETCH_Instr_unnatural_addr_trap_a0;
            logic [31:0] \//@0$upd_csr_cycle ;
            assign \//@0$upd_csr_cycle = FETCH_Instr_upd_csr_cycle_a0;
            logic [31:0] \//@0$upd_csr_cycleh ;
            assign \//@0$upd_csr_cycleh = FETCH_Instr_upd_csr_cycleh_a0;
            logic [31:0] \//@0$upd_csr_instret ;
            assign \//@0$upd_csr_instret = FETCH_Instr_upd_csr_instret_a0;
            logic [31:0] \//@0$upd_csr_instreth ;
            assign \//@0$upd_csr_instreth = FETCH_Instr_upd_csr_instreth_a0;
            logic [31:0] \//@0$upd_csr_time ;
            assign \//@0$upd_csr_time = FETCH_Instr_upd_csr_time_a0;
            logic [31:0] \//@0$upd_csr_timeh ;
            assign \//@0$upd_csr_timeh = FETCH_Instr_upd_csr_timeh_a0;
            logic  \//@0$valid_csr ;
            assign \//@0$valid_csr = FETCH_Instr_valid_csr_a0;
            logic  \//@0$valid_decode ;
            assign \//@0$valid_decode = FETCH_Instr_valid_decode_a0;
            logic  \//@0$valid_decode_branch ;
            assign \//@0$valid_decode_branch = FETCH_Instr_valid_decode_branch_a0;
            logic  \//@0$valid_dest_reg_valid ;
            assign \//@0$valid_dest_reg_valid = FETCH_Instr_valid_dest_reg_valid_a0;
            logic  \//@0$valid_exe ;
            assign \//@0$valid_exe = FETCH_Instr_valid_exe_a0;
            logic  \//@0$valid_ld ;
            assign \//@0$valid_ld = FETCH_Instr_valid_ld_a0;
            logic  \//@0$valid_st ;
            assign \//@0$valid_st = FETCH_Instr_valid_st_a0;
            logic  \///@0$waitd ;
            assign \///@0$waitd = FETCH_Instr_waitd_a0;
            logic  \///@0$waitm ;
            assign \///@0$waitm = FETCH_Instr_waitm_a0;
            logic  \///@0$wrd ;
            assign \///@0$wrd = FETCH_Instr_wrd_a0;
            logic  \///@0$wrm ;
            assign \///@0$wrm = FETCH_Instr_wrm_a0;
            logic [31:0] \//?$valid_exe@0$xor_rslt ;
            assign \//?$valid_exe@0$xor_rslt = FETCH_Instr_xor_rslt_a0;
            logic [31:0] \//?$valid_exe@0$xori_rslt ;
            assign \//?$valid_exe@0$xori_rslt = FETCH_Instr_xori_rslt_a0;

            //
            // Scope: /bank[3:0]
            //
            for (bank = 0; bank <= 3; bank++) begin : \/bank 
               logic [31:0] \///@0$addr ;
               assign \///@0$addr = L1_FETCH_Instr_Bank[bank].L1_addr_a0;
               logic [(32 / 4) - 1 : 0] \///?$spec_ld@0$ld_data ;
               assign \///?$spec_ld@0$ld_data = L1_FETCH_Instr_Bank[bank].L1_ld_data_a0;
               logic  \///@0$spec_ld ;
               assign \///@0$spec_ld = L1_FETCH_Instr_Bank[bank].L1_spec_ld_a0;
               logic [3:0] \///@0$st_mask ;
               assign \///@0$st_mask = L1_FETCH_Instr_Bank[bank].L1_st_mask_a0;
               logic [31:0] \///@0$st_value ;
               assign \///@0$st_value = L1_FETCH_Instr_Bank[bank].L1_st_value_a0;
               logic  \///@0$valid_st ;
               assign \///@0$valid_st = L1_FETCH_Instr_Bank[bank].L1_valid_st_a0;

               //
               // Scope: /mem[31:0]
               //
               for (mem = 0; mem <= 31; mem++) begin : \/mem 
                  logic [(32 / 4) - 1 : 0] \///@0$Value ;
                  assign \///@0$Value = L1_FETCH_Instr_Bank[bank].L1_Mem_Value_a0[mem];
               end
            end

            //
            // Scope: /div1
            //
            if (1) begin : \/div1 
               logic [31:0] \///@0$div_insn ;
               assign \///@0$div_insn = FETCH_Instr_Div1_div_insn_a0;
               logic [2:0] \///@0$opcode ;
               assign \///@0$opcode = FETCH_Instr_Div1_opcode_a0;
            end

            //
            // Scope: /hold_inst
            //
            if (1) begin : \/hold_inst 
               logic [4:0] \///@0$dest_reg ;
               assign \///@0$dest_reg = FETCH_Instr_HoldInst_dest_reg_a0;
               logic [31:2] \///@0$pc ;
               assign \///@0$pc = FETCH_Instr_HoldInst_pc_a0;

               //
               // Scope: /src[2:1]
               //
               for (src = 1; src <= 2; src++) begin : \/src 
                  logic  \////@0$dummy ;
                  assign \////@0$dummy = L1_FETCH_Instr_HoldInst_Src[src].L1_dummy_a0;
               end
            end

            //
            // Scope: /mul1
            //
            if (1) begin : \/mul1 
               logic [31:0] \///@0$mul_insn ;
               assign \///@0$mul_insn = FETCH_Instr_Mul1_mul_insn_a0;
               logic [2:0] \///@0$opcode ;
               assign \///@0$opcode = FETCH_Instr_Mul1_opcode_a0;
            end

            //
            // Scope: /orig_inst
            //
            if (1) begin : \/orig_inst 
               logic [4:0] \//?$second_issue/@0$dest_reg ;
               assign \//?$second_issue/@0$dest_reg = FETCH_Instr_OrigInst_dest_reg_a0;
               logic [31:2] \//?$second_issue/@0$pc ;
               assign \//?$second_issue/@0$pc = FETCH_Instr_OrigInst_pc_a0;

               //
               // Scope: /src[2:1]
               //
               for (src = 1; src <= 2; src++) begin : \/src 
                  logic  \//?$second_issue//@0$dummy ;
                  assign \//?$second_issue//@0$dummy = L1_FETCH_Instr_OrigInst_Src[src].L1_dummy_a0;
               end
            end

            //
            // Scope: /orig_load_inst
            //
            if (1) begin : \/orig_load_inst 
               logic [1:0] \//?$second_issue_ld/@0$addr ;
               assign \//?$second_issue_ld/@0$addr = FETCH_Instr_OrigLoadInst_addr_a0;
               logic [4:0] \//?$second_issue_ld/@0$dest_reg ;
               assign \//?$second_issue_ld/@0$dest_reg = FETCH_Instr_OrigLoadInst_dest_reg_a0;
               logic [3:0] \//?$second_issue_ld/?$spec_ld_cond@0$ld_mask ;
               assign \//?$second_issue_ld/?$spec_ld_cond@0$ld_mask = FETCH_Instr_OrigLoadInst_ld_mask_a0;
               logic [31:0] \//?$second_issue_ld/?$spec_ld_cond@0$ld_rslt ;
               assign \//?$second_issue_ld/?$spec_ld_cond@0$ld_rslt = FETCH_Instr_OrigLoadInst_ld_rslt_a0;
               logic  \//?$second_issue_ld/@0$ld_st_half ;
               assign \//?$second_issue_ld/@0$ld_st_half = FETCH_Instr_OrigLoadInst_ld_st_half_a0;
               logic  \//?$second_issue_ld/@0$ld_st_word ;
               assign \//?$second_issue_ld/@0$ld_st_word = FETCH_Instr_OrigLoadInst_ld_st_word_a0;
               logic [31:0] \//?$second_issue_ld/@0$ld_value ;
               assign \//?$second_issue_ld/@0$ld_value = FETCH_Instr_OrigLoadInst_ld_value_a0;
               logic [31:2] \//?$second_issue_ld/@0$pc ;
               assign \//?$second_issue_ld/@0$pc = FETCH_Instr_OrigLoadInst_pc_a0;
               logic [2:2] \//?$second_issue_ld/@0$raw_funct3 ;
               assign \//?$second_issue_ld/@0$raw_funct3 = FETCH_Instr_OrigLoadInst_raw_funct3_a0;
               logic  \//?$second_issue_ld/?$spec_ld_cond@0$sign_bit ;
               assign \//?$second_issue_ld/?$spec_ld_cond@0$sign_bit = FETCH_Instr_OrigLoadInst_sign_bit_a0;
               logic  \//?$second_issue_ld/@0$spec_ld ;
               assign \//?$second_issue_ld/@0$spec_ld = FETCH_Instr_OrigLoadInst_spec_ld_a0;
               logic  \//?$second_issue_ld/@0$spec_ld_cond ;
               assign \//?$second_issue_ld/@0$spec_ld_cond = FETCH_Instr_OrigLoadInst_spec_ld_cond_a0;

               //
               // Scope: /src[2:1]
               //
               for (src = 1; src <= 2; src++) begin : \/src 
                  logic  \//?$second_issue_ld//@0$dummy ;
                  assign \//?$second_issue_ld//@0$dummy = L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0;
               end
            end

            //
            // Scope: /regs[31:1]
            //
            for (regs = 1; regs <= 31; regs++) begin : \/regs 
               logic  \///@-1$pending ;
               assign \///@-1$pending = FETCH_Instr_Regs_pending_n1[regs];
               logic [31:0] \//@0$value ;
               assign \//@0$value = FETCH_Instr_Regs_value_a0[regs];
            end

            //
            // Scope: /src[2:1]
            //
            for (src = 1; src <= 2; src++) begin : \/src 
               logic  \///@0$dummy ;
               assign \///@0$dummy = L1c_FETCH_Instr_Src[src].L1_dummy_a0;
               logic  \//?$valid_decode/@0$is_reg ;
               assign \//?$valid_decode/@0$is_reg = L1_FETCH_Instr_Src[src].L1_is_reg_a0;
               logic  \///@0$is_reg_condition ;
               assign \///@0$is_reg_condition = L1b_FETCH_Instr_Src[src].L1_is_reg_condition_a0;
               logic  \///?$is_reg_condition@0$pending ;
               assign \///?$is_reg_condition@0$pending = L1b_FETCH_Instr_Src[src].L1_pending_a0;
               logic [4:0] \//?$valid_decode/@0$reg ;
               assign \//?$valid_decode/@0$reg = L1_FETCH_Instr_Src[src].L1_reg_a0;
               logic [31:0] \///?$is_reg_condition@0$reg_value ;
               assign \///?$is_reg_condition@0$reg_value = L1b_FETCH_Instr_Src[src].L1_reg_value_a0;
               logic  \///@0$replay ;
               assign \///@0$replay = FETCH_Instr_Src_replay_a0[src];
               logic [31:0] \///?$is_reg_condition@0$rf_value ;
               assign \///?$is_reg_condition@0$rf_value = L1b_FETCH_Instr_Src[src].L1_rf_value_a0;
               logic  \///@0$unconditioned_is_reg ;
               assign \///@0$unconditioned_is_reg = FETCH_Instr_Src_unconditioned_is_reg_a0[src];
               logic [4:0] \///@0$unconditioned_reg ;
               assign \///@0$unconditioned_reg = FETCH_Instr_Src_unconditioned_reg_a0[src];
               logic [31:0] \///@0$unconditioned_reg_value ;
               assign \///@0$unconditioned_reg_value = FETCH_Instr_Src_unconditioned_reg_value_a0[src];
            end
         end

         //
         // Scope: /instr_mem[15:0]
         //
         for (instr_mem = 0; instr_mem <= 15; instr_mem++) begin : \/instr_mem 
            logic [31:0] \//@0$instr ;
            assign \//@0$instr = L1_FETCH_InstrMem[instr_mem].L1_instr_a0;
            logic [40*8-1:0] \//@0$instr_str ;
            assign \//@0$instr_str = FETCH_InstrMem_instr_str_a0[instr_mem];
         end
      end

      //
      // Scope: |mem
      //
      if (1) begin : \|mem 

         //
         // Scope: /data
         //
         if (1) begin : \/data 
            logic [1:0] \//@0$addr ;
            assign \//@0$addr = MEM_Data_addr_a0;
            logic [4:0] \//@0$dest_reg ;
            assign \//@0$dest_reg = MEM_Data_dest_reg_a0;
            logic  \//@0$ld_st_half ;
            assign \//@0$ld_st_half = MEM_Data_ld_st_half_a0;
            logic  \//@0$ld_st_word ;
            assign \//@0$ld_st_word = MEM_Data_ld_st_word_a0;
            logic [31:0] \//@1$ld_value ;
            assign \//@1$ld_value = MEM_Data_ld_value_a1;
            logic [31:2] \//@0$pc ;
            assign \//@0$pc = MEM_Data_pc_a0;
            logic [2:2] \//@0$raw_funct3 ;
            assign \//@0$raw_funct3 = MEM_Data_raw_funct3_a0;
            logic  \//@0$spec_ld ;
            assign \//@0$spec_ld = MEM_Data_spec_ld_a0;
            logic  \//@0$valid_ld ;
            assign \//@0$valid_ld = MEM_Data_valid_ld_a0;

            //
            // Scope: /src[2:1]
            //
            for (src = 1; src <= 2; src++) begin : \/src 
               logic  \///@0$dummy ;
               assign \///@0$dummy = L1_MEM_Data_Src[src].L1_dummy_a0;
            end
         end
      end


   end



// ---------- Generated Code Ends ----------
//_\TLV
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 6081 // Instantiated from top.tlv, 49 as: m4+warpv_top()
/* verilator lint_on WIDTH */ // Let's be strict about bit widths.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6083 as: m5+ifelse(m5_calc(m5_NUM_CORES > 1), 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 6106 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__1.
// Single Core.
// m5+warpv() (but inlined to reduce macro depth)
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3512 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6110 as: m5+cpu(/top)
// Generated logic
// Instantiate the _gen macro for the right ISA. (This approach is required for an m5-defined name.)
//_\source M5-FN-riscv_gen 0 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3516 as: m5+m4_gen()
//_\end_source
// Instruction memory and fetch of $raw.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1627 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3518 as: m5+m5_IMEM_MACRO_NAME(m5_PROG_NAME)
// ==============
// IMem and Fetch
// ==============
/* DMEM_STYLE: ARRAY, FORMAL: 0 */
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1634 as: m5+ifelse(m5_FORMAL, 1,
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1695 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__6.
// Default to HARDCODED_ARRAY
// For simulation
// --------------
// Define the program. (This approach is required for an m5-defined name.)
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1485 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1702 as: m5+m5_prog()
// /==========================\
// | M-extension Test Program |
// \==========================/
//
//3 MULs followed by 3 DIVs, check r11-r15 for correct results
// Inst #0: ORI x8, zero, 0b1011
// Inst #1: ORI x9, zero, 0b1010
// Inst #2: ORI x10, zero, 0b10101010
// Inst #3: MUL x11, x8, x9
// Inst #4: ORI x6, zero, 0b0
// Inst #5: SW x6, x11, 0b0
// Inst #6: MUL x12, x9, x10
// Inst #7: LW x4, x6, 0b0
// Inst #8: ADDI x6, x6, 0b100
// Inst #9: SW x6, x12, 0b0
// Inst #10: MUL x13, x8, x10
// Inst #11: DIV x14, x11, x8
// Inst #12: DIV x15, x13, x10
// Inst #13: LW x5, x6, 0b0
// Inst #14: ADDI x4, zero, 0b101101
// Inst #15: BGE x8, x9, 0b111111111110
//_\end_source
/*SV_plus*/
// The program in an instruction memory.
logic [31:0] instrs [0:16-1];
logic [40*8-1:0] instr_strs [0:16];
assign instrs[0] = {12'b1011, 5'd0, 3'b110, 5'd8, 7'b0010011}; assign instrs[1] = {12'b1010, 5'd0, 3'b110, 5'd9, 7'b0010011}; assign instrs[2] = {12'b10101010, 5'd0, 3'b110, 5'd10, 7'b0010011}; assign instrs[3] = {7'b0000001, 5'd9, 5'd8, 3'b000, 5'd11, 7'b0110011}; assign instrs[4] = {12'b0, 5'd0, 3'b110, 5'd6, 7'b0010011}; assign instrs[5] = {7'b0000000, 5'd11, 5'd6, 3'b010, 5'b00000, 7'b0100011}; assign instrs[6] = {7'b0000001, 5'd10, 5'd9, 3'b000, 5'd12, 7'b0110011}; assign instrs[7] = {12'b0, 5'd6, 3'b010, 5'd4, 7'b0000011}; assign instrs[8] = {12'b100, 5'd6, 3'b000, 5'd6, 7'b0010011}; assign instrs[9] = {7'b0000000, 5'd12, 5'd6, 3'b010, 5'b00000, 7'b0100011}; assign instrs[10] = {7'b0000001, 5'd10, 5'd8, 3'b000, 5'd13, 7'b0110011}; assign instrs[11] = {7'b0000001, 5'd8, 5'd11, 3'b100, 5'd14, 7'b0110011}; assign instrs[12] = {7'b0000001, 5'd10, 5'd13, 3'b100, 5'd15, 7'b0110011}; assign instrs[13] = {12'b0, 5'd6, 3'b010, 5'd5, 7'b0000011}; assign instrs[14] = {12'b101101, 5'd0, 3'b000, 5'd4, 7'b0010011}; assign instrs[15] = {1'b0, 6'b111111, 5'd9, 5'd8, 3'b101, 4'b1111, 1'b1, 7'b1100011};
// String representations of the instructions for debug.
assign instr_strs[0] = "(I) ORI x8,zero,0b1011 "; assign instr_strs[1] = "(I) ORI x9,zero,0b1010 "; assign instr_strs[2] = "(I) ORI x10,zero,0b10101010 "; assign instr_strs[3] = "(R) MUL x11,x8,x9 "; assign instr_strs[4] = "(I) ORI x6,zero,0b0 "; assign instr_strs[5] = "(S) SW x6,x11,0b0 "; assign instr_strs[6] = "(R) MUL x12,x9,x10 "; assign instr_strs[7] = "(I) LW x4,x6,0b0 "; assign instr_strs[8] = "(I) ADDI x6,x6,0b100 "; assign instr_strs[9] = "(S) SW x6,x12,0b0 "; assign instr_strs[10] = "(R) MUL x13,x8,x10 "; assign instr_strs[11] = "(R) DIV x14,x11,x8 "; assign instr_strs[12] = "(R) DIV x15,x13,x10 "; assign instr_strs[13] = "(I) LW x5,x6,0b0 "; assign instr_strs[14] = "(I) ADDI x4,zero,0b101101 "; assign instr_strs[15] = "(B) BGE x8,x9,0b111111111110 ";
assign instr_strs[16] = "END ";
//_|fetch
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1715 as: m5+ifelse(m5_VIZ, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1716 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__7.
for (instr_mem = 0; instr_mem <= 15; instr_mem++) begin : L1_FETCH_InstrMem //_/instr_mem
// For $instr.
logic [31:0] L1_instr_a0;
//_@0
assign L1_instr_a0[31:0] = instrs[instr_mem];
assign FETCH_InstrMem_instr_str_a0[instr_mem][40*8-1:0] = instr_strs[instr_mem];
end
//_\end_source
//_\end_source
//_/instr
//_@0
//_?$fetch
assign FETCH_Instr_raw_a0[31:0] = instrs[FETCH_Instr_Pc_a0[5:2]];
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\end_source
// /=========\
// | The CPU |
// \=========/
//_|fetch
//_/instr
// Provide a longer reset to cover the pipeline depth.
//_@-1
assign FETCH_Instr_soft_reset_n1 = (1'b0) || reset;
assign FETCH_Instr_Cnt_n2[7:0] = FETCH_Instr_soft_reset_n1 ? 8'b0 : // reset
FETCH_Instr_Cnt_n1 == 8'hFF ? 8'hFF : // max out to avoid wrapping
FETCH_Instr_Cnt_n1 + 8'b1; // increment
assign FETCH_Instr_reset_n1 = FETCH_Instr_soft_reset_n1 || FETCH_Instr_Cnt_n1 < 5;
//_@0
assign FETCH_Instr_fetch_a0 = ! FETCH_Instr_reset_a0 && ! FETCH_Instr_NoFetch_a0;
// (m5_IMEM_MACRO_NAME instantiation produces ?$fetch$raw.)
//_@0
// ========
// Overview
// ========
// Terminology:
//
// Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
// and the returning_ld and the instruction it clobbers are one in the same).
// ISA Instruction: An instruction, as defined by the ISA.
// Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
// Path (of an instruction): The sequence of instructions that led to a particular instruction.
// Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
// Redirect: Adjust the PC from the predicted next-PC.
// Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
// Bubbles: The cycles in the redirect shadow.
// Commit: Results are made visible to subsequent instructions.
// Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
// redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
// aborted instruction.
// Retire: Commit results of an ISA instruction.
// Control flow:
//
// Redirects include (earliest to latest):
// o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
// one-cycle redirect to repeat the clobbered instruction.
// o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
// (This might be followed up by a mispredition.)
// o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a long-latency/2nd issuing instruction))
// o Jump: A jump instruction.
// o Mispredicted branch: A branch condition was mispredicted.
// o Aborting traps: (aborting) illegal instructions, others?
// o Non-aborting traps: misaligned PC target
// ==============
// Redirect Logic
// ==============
// PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
// instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
// whether the instruction n instructions prior to this instruction is on its path.
//
// $GoodPathMask for Redir'edX => {o,X,o,y,y,y,o,o} == {1,1,1,1,0,0,1,1}
// Waterfall View: |
// V
// 0: oooooooo Good-path
// 1: InstX ooooooXo (Non-aborting) Good-path
// 2: ooooooxx
// 3: InstY ooYyyxxx (Aborting)
// 4: InstZ ooyyxZxx
// 5: Redir'edY oyyxxxxx
// 6: TargetY ooxxxxxx
// 7: Redir'edX oxxxxxxx
// 8: TargetX oooooooo Good-path
// 9: Not redir'edZ oooooooo Good-path
//
// Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
// instructions. A trigger in the 1st depicted stage, m5_NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
// a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
// no impact on the $GoodPathMask.
//
// Waveform View:
//
// Inst 0123456789
// ---------- /
// GPM[7] ooxxxxxxoo
// GPM[6] oXxxxxxxoo
// GPM[5] oooxZxxxoo
// GPM[4] oooyxxxxoo
// GPM[3] oooyyxxxoo
// GPM[2] oooYyyxxoo
// GPM[1] oooooyoxoo
// GPM[0] oooooooooo
// /
// Triggers for InstY
//
// In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
// in the shadow, down to the redirect target (GPM[0]).
//
// Terminology:
// Triggering instruction: The instruction on which the condition is detected.
// Redirected instruction: The instruction whose next PC is redirected.
// Redirection target instruction: The first new-path instruction resulting from the redirection.
//
// Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
// because their instructions are on the path of the redirected instructions. Z is not on the path of its
// potentially-redirected instruction, so no redirection happens.
//
// For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
// redirect target, so later-stage redirects take priority in the PC-mux.
//
// Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
// not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
// same stage, this is accomplished by the PC-mux prioritization.)
// Macros are defined elsewhere based on the ordered set of conditions that generate code here.
// Redirect Shadow
// A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
// Index 1 is ahead by 1, etc.
// In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
// (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
// The LSB is fetch-valid. It only exists for m5_prev_instr_valid_through macro.
assign FETCH_Instr_next_good_path_mask_a0[1+1:0] =
// Shift up and mask w/ redirect conditions.
{FETCH_Instr_GoodPathMask_a0[1:0]
// & terms for each condition (order doesn't matter since masks are the same within a cycle)
& ((FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_replay_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_jump_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_mispred_branch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_indirect_jump_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_non_pipelined_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_aborting_trap_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{0{1'b1}}, {2{1'b0}}} : {2{1'b1}}) & ((FETCH_Instr_non_aborting_trap_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1 || FETCH_Instr_aborting_trap_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}),
1'b1}; // Shift in 1'b1 (fetch-valid).
assign FETCH_Instr_GoodPathMask_n1[1+1:0] =
FETCH_Instr_reset_n1 ? 3'b0 : // All bad-path (through self) on reset (next mask based on next reset).
FETCH_Instr_next_good_path_mask_a0;
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3656 as: m5+ifelse(m5_FORMAL, 1,
//_\end_source
// A returning load clobbers the instruction.
// (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
// it is non-speculative. Both could easily be fixed.)
assign FETCH_Instr_second_issue_ld_a0 = MEM_Data_valid_ld_a1 && 1'b1;
assign FETCH_Instr_second_issue_a0 = (FETCH_Instr_second_issue_ld_a0 || FETCH_Instr_second_issue_div_mul_a0 );
// Recirculate returning load or the div_mul_result from /orig_inst scope
// This reduces significantly once $ANY acts on subscope.
//_?$second_issue_ld
// This scope holds the original load for a returning load.
//_/orig_load_inst
assign {FETCH_Instr_OrigLoadInst_addr_a0[1:0], FETCH_Instr_OrigLoadInst_dest_reg_a0[4:0], FETCH_Instr_OrigLoadInst_ld_st_half_a0, FETCH_Instr_OrigLoadInst_ld_st_word_a0, FETCH_Instr_OrigLoadInst_ld_value_a0[31:0], FETCH_Instr_OrigLoadInst_pc_a0[31:2], FETCH_Instr_OrigLoadInst_raw_funct3_a0[2], FETCH_Instr_OrigLoadInst_spec_ld_a0} = {MEM_Data_addr_a1, MEM_Data_dest_reg_a1, MEM_Data_ld_st_half_a1, MEM_Data_ld_st_word_a1, MEM_Data_ld_value_a1, MEM_Data_pc_a1, MEM_Data_raw_funct3_a1, MEM_Data_spec_ld_a1};
for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigLoadInst_Src //_/src
// For $dummy.
logic L1_dummy_a0;
assign {L1_dummy_a0} = {L1_MEM_Data_Src[src].L1_dummy_a1};
end
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3684 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_?$second_issue
//_/orig_inst
// pull values from /orig_load_inst or /hold_inst depending on which second issue
assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0], FETCH_Instr_OrigInst_pc_a0[31:2]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0} : FETCH_Instr_second_issue_div_mul_a0 ? {FETCH_Instr_HoldInst_dest_reg_a1, FETCH_Instr_HoldInst_pc_a1} : {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0};
for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigInst_Src //_/src
// For $dummy.
logic L1_dummy_a0;
assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} : FETCH_Instr_second_issue_div_mul_a0 ? {L1_FETCH_Instr_HoldInst_Src[src].L1_dummy_a1} : {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0};
end
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3697 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
// Next PC
assign FETCH_Instr_pc_inc_a0[31:2] = FETCH_Instr_Pc_a0 + 30'b1;
// Current parsing does not allow concatenated state on left-hand-side, so, first, a non-state expression.
assign {FETCH_Instr_next_pc_a0[31:2], FETCH_Instr_next_no_fetch_a0} =
FETCH_Instr_reset_a0 ? {29'b0, 2'b0} : /// Start PC at the assembly code "reset" label or address 0.
// ? : terms for each condition (order does matter)
(FETCH_Instr_non_aborting_trap_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1 || FETCH_Instr_aborting_trap_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_trap_target_a1, 1'b0} : (FETCH_Instr_aborting_trap_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_trap_target_a1, 1'b0} : (FETCH_Instr_non_pipelined_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_pc_inc_a1, 1'b1} : (FETCH_Instr_indirect_jump_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_indirect_jump_target_a0, 1'b0} : (FETCH_Instr_mispred_branch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_branch_redir_pc_a0, 1'b0} : (FETCH_Instr_jump_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_jump_target_a0, 1'b0} : (FETCH_Instr_replay_a0 && !(1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0, 1'b0} : (FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0, 1'b1} : (FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0, 1'b0} :
({FETCH_Instr_pc_inc_a0, 1'b0});
// Then as state.
assign FETCH_Instr_Pc_n1[31:2] = FETCH_Instr_next_pc_a0;
assign FETCH_Instr_NoFetch_n1 = FETCH_Instr_next_no_fetch_a0;
//_@0
// ======
// DECODE
// ======
// Decode of the fetched instruction
assign FETCH_Instr_valid_decode_a0 = FETCH_Instr_fetch_a0; // Always decode if we fetch.
assign FETCH_Instr_valid_decode_branch_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_branch_a0;
// A load that will return later.
//$split_ld = $spec_ld && 1'b⌈⌉m5_INJECT_RETURNING_LD;
// Instantiate the program. (This approach is required for an m5-defined name.)
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1897 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3729 as: m5+m5_decode_macro_name()
// TODO: ?$valid_<stage> conditioning should be replaced by use of m5_prev_instr_valid_through(..).
//_?$valid_decode
// =================================
// Extract fields of $raw (instruction) into $raw_<field>[x:0].
assign {FETCH_Instr_raw_funct7_a0[6:0], FETCH_Instr_raw_rs2_a0[4:0], FETCH_Instr_raw_rs1_a0[4:0], FETCH_Instr_raw_funct3_a0[2:0], FETCH_Instr_raw_rd_a0[4:0], FETCH_Instr_raw_op5_a0[4:0], FETCH_Instr_raw_op2_a0[1:0]} = FETCH_Instr_raw_a0;
`BOGUS_USE(FETCH_Instr_raw_op2_a0) // Delete once it's used.
// Extract immediate fields into type-specific signals.
// (User ISA Manual 2.2, Fig. 2.4)
assign FETCH_Instr_raw_i_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:20]};
assign FETCH_Instr_raw_s_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:7]};
assign FETCH_Instr_raw_b_imm_a0[31:0] = {{20{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[7], FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:8], 1'b0};
assign FETCH_Instr_raw_u_imm_a0[31:0] = {FETCH_Instr_raw_a0[31:12], {12{1'b0}}};
assign FETCH_Instr_raw_j_imm_a0[31:0] = {{12{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[19:12], FETCH_Instr_raw_a0[20], FETCH_Instr_raw_a0[30:21], 1'b0};
// Extract other type/instruction-specific fields.
assign FETCH_Instr_raw_shamt_a0[6:0] = FETCH_Instr_raw_a0[26:20];
assign FETCH_Instr_raw_aq_a0 = FETCH_Instr_raw_a0[26];
assign FETCH_Instr_raw_rl_a0 = FETCH_Instr_raw_a0[25];
assign FETCH_Instr_raw_rs3_a0[4:0] = FETCH_Instr_raw_a0[31:27];
assign FETCH_Instr_raw_rm_a0[2:0] = FETCH_Instr_raw_funct3_a0;
`BOGUS_USE(FETCH_Instr_raw_shamt_a0 FETCH_Instr_raw_aq_a0 FETCH_Instr_raw_rl_a0 FETCH_Instr_raw_rs3_a0 FETCH_Instr_raw_rm_a0) // Avoid "unused" messages. Remove these as they become used.
// Instruction type decode
//_\source M5-FN-instr_types_decode 0 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1921 as: m5+instr_types_decode()
/*SV_plus*/
assign FETCH_Instr_is_i_type_a0 = (((0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_r_type_a0 = (((0 | (1 << 5'b01011) | (1 << 5'b01100) | (1 << 5'b01110) | (1 << 5'b10100)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_r2_type_a0 = (((0) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_r4_type_a0 = (((0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_s_type_a0 = (((0 | (1 << 5'b01000) | (1 << 5'b01001)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_b_type_a0 = (((0 | (1 << 5'b11000)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_j_type_a0 = (((0 | (1 << 5'b11011)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is_u_type_a0 = (((0 | (1 << 5'b00101) | (1 << 5'b01101)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
assign FETCH_Instr_is___type_a0 = (((0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0;
//_\end_source
// Instruction decode.
//_\source M5-FN-riscv_decode_expr 0 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1924 as: m5+riscv_decode_expr()
assign FETCH_Instr_is_lui_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01101;
assign FETCH_Instr_is_auipc_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00101;
assign FETCH_Instr_is_jal_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11011;
assign FETCH_Instr_is_jalr_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11001 && FETCH_Instr_raw_funct3_a0 == 3'b000;
assign FETCH_Instr_is_beq_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
assign FETCH_Instr_is_bne_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
assign FETCH_Instr_is_blt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
assign FETCH_Instr_is_bge_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
assign FETCH_Instr_is_bltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b110;
assign FETCH_Instr_is_bgeu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b111;
assign FETCH_Instr_is_lb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
assign FETCH_Instr_is_lh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
assign FETCH_Instr_is_lw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
assign FETCH_Instr_is_lbu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
assign FETCH_Instr_is_lhu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
assign FETCH_Instr_is_sb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
assign FETCH_Instr_is_sh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
assign FETCH_Instr_is_sw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
assign FETCH_Instr_is_addi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b000;
assign FETCH_Instr_is_slti_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
assign FETCH_Instr_is_sltiu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
assign FETCH_Instr_is_xori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b100;
assign FETCH_Instr_is_ori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
assign FETCH_Instr_is_andi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
assign FETCH_Instr_is_slli_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b001 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b000000;
assign FETCH_Instr_is_srli_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b000000;
assign FETCH_Instr_is_srai_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b010000;
assign FETCH_Instr_is_add_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_sub_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0100000;
assign FETCH_Instr_is_sll_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b001 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_slt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b010 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_sltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b011 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_xor_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b100 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_srl_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_sra_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0100000;
assign FETCH_Instr_is_or_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b110 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_and_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b111 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
assign FETCH_Instr_is_csrrw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b001;
assign FETCH_Instr_is_csrrs_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
assign FETCH_Instr_is_csrrc_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
assign FETCH_Instr_is_csrrwi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b101;
assign FETCH_Instr_is_csrrsi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
assign FETCH_Instr_is_csrrci_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
assign FETCH_Instr_is_mul_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_mulh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b001 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_mulhsu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b010 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_mulhu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b011 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_div_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b100 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_divu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_rem_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b110 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
assign FETCH_Instr_is_remu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b111 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000001;
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1926 as: m5+ifelse(m5_EXT_M, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1927 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__11.
// Instruction requires integer mul/div unit and is long-latency.
assign FETCH_Instr_divtype_instr_a0 = (FETCH_Instr_is_div_instr_a0 || FETCH_Instr_is_divu_instr_a0 || FETCH_Instr_is_rem_instr_a0 || FETCH_Instr_is_remu_instr_a0);
assign FETCH_Instr_multype_instr_a0 = (FETCH_Instr_is_mul_instr_a0 || FETCH_Instr_is_mulh_instr_a0 || FETCH_Instr_is_mulhsu_instr_a0 || FETCH_Instr_is_mulhu_instr_a0);
assign FETCH_Instr_div_mul_a0 = (FETCH_Instr_multype_instr_a0 || FETCH_Instr_divtype_instr_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1939 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1997 as: m5+ifelse(m5_EXT_B, 1,
//_\end_source
assign FETCH_Instr_is_srli_srai_instr_a0 = FETCH_Instr_is_srli_instr_a0 || FETCH_Instr_is_srai_instr_a0;
// Some I-type instructions have a funct7 field rather than immediate bits, so these must factor into the illegal instruction expression explicitly.
assign FETCH_Instr_illegal_itype_with_funct7_a0 = ( FETCH_Instr_is_srli_srai_instr_a0 ) && | {FETCH_Instr_raw_funct7_a0[6], FETCH_Instr_raw_funct7_a0[4:0]};
assign FETCH_Instr_illegal_a0 = (FETCH_Instr_illegal_itype_with_funct7_a0 && ! FETCH_Instr_is_lui_instr_a0 && ! FETCH_Instr_is_auipc_instr_a0 && ! FETCH_Instr_is_jal_instr_a0 && ! FETCH_Instr_is_jalr_instr_a0 && ! FETCH_Instr_is_beq_instr_a0 && ! FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_is_blt_instr_a0 && ! FETCH_Instr_is_bge_instr_a0 && ! FETCH_Instr_is_bltu_instr_a0 && ! FETCH_Instr_is_bgeu_instr_a0 && ! FETCH_Instr_is_lb_instr_a0 && ! FETCH_Instr_is_lh_instr_a0 && ! FETCH_Instr_is_lw_instr_a0 && ! FETCH_Instr_is_lbu_instr_a0 && ! FETCH_Instr_is_lhu_instr_a0 && ! FETCH_Instr_is_sb_instr_a0 && ! FETCH_Instr_is_sh_instr_a0 && ! FETCH_Instr_is_sw_instr_a0 && ! FETCH_Instr_is_addi_instr_a0 && ! FETCH_Instr_is_slti_instr_a0 && ! FETCH_Instr_is_sltiu_instr_a0 && ! FETCH_Instr_is_xori_instr_a0 && ! FETCH_Instr_is_ori_instr_a0 && ! FETCH_Instr_is_andi_instr_a0 && ! FETCH_Instr_is_slli_instr_a0 && ! FETCH_Instr_is_srli_instr_a0 && ! FETCH_Instr_is_srai_instr_a0 && ! FETCH_Instr_is_add_instr_a0 && ! FETCH_Instr_is_sub_instr_a0 && ! FETCH_Instr_is_sll_instr_a0 && ! FETCH_Instr_is_slt_instr_a0 && ! FETCH_Instr_is_sltu_instr_a0 && ! FETCH_Instr_is_xor_instr_a0 && ! FETCH_Instr_is_srl_instr_a0 && ! FETCH_Instr_is_sra_instr_a0 && ! FETCH_Instr_is_or_instr_a0 && ! FETCH_Instr_is_and_instr_a0 && ! FETCH_Instr_is_csrrw_instr_a0 && ! FETCH_Instr_is_csrrs_instr_a0 && ! FETCH_Instr_is_csrrc_instr_a0 && ! FETCH_Instr_is_csrrwi_instr_a0 && ! FETCH_Instr_is_csrrsi_instr_a0 && ! FETCH_Instr_is_csrrci_instr_a0 && ! FETCH_Instr_is_mul_instr_a0 && ! FETCH_Instr_is_mulh_instr_a0 && ! FETCH_Instr_is_mulhsu_instr_a0 && ! FETCH_Instr_is_mulhu_instr_a0 && ! FETCH_Instr_is_div_instr_a0 && ! FETCH_Instr_is_divu_instr_a0 && ! FETCH_Instr_is_rem_instr_a0 && ! FETCH_Instr_is_remu_instr_a0) ||
(FETCH_Instr_raw_a0[1:0] != 2'b11); // All legal instructions have opcode[1:0] == 2'b11. We ignore these bits in decode logic.
assign FETCH_Instr_conditional_branch_a0 = FETCH_Instr_is_b_type_a0;
assign FETCH_Instr_jump_a0 = FETCH_Instr_is_jal_instr_a0; // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
assign FETCH_Instr_branch_a0 = FETCH_Instr_is_b_type_a0;
assign FETCH_Instr_indirect_jump_a0 = FETCH_Instr_is_jalr_instr_a0;
//_?$valid_decode
assign FETCH_Instr_ld_a0 = FETCH_Instr_raw_a0[6:3] == 4'b0;
assign FETCH_Instr_st_a0 = FETCH_Instr_is_s_type_a0;
assign FETCH_Instr_ld_st_a0 = FETCH_Instr_ld_a0 || FETCH_Instr_st_a0;
assign FETCH_Instr_ld_st_word_a0 = FETCH_Instr_ld_st_a0 && (FETCH_Instr_raw_funct3_a0[1] == 1'b1);
assign FETCH_Instr_ld_st_half_a0 = FETCH_Instr_ld_st_a0 && (FETCH_Instr_raw_funct3_a0[1:0] == 2'b01);
//$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
`BOGUS_USE(FETCH_Instr_is___type_a0 FETCH_Instr_is_u_type_a0)
// Output signals.
for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src //_/src
// For $is_reg.
logic L1_is_reg_a0;
// For $reg.
logic [4:0] L1_reg_a0;
// Reg valid for this source, based on instruction type.
assign L1_is_reg_a0 =
(FETCH_Instr_is_r_type_a0 || FETCH_Instr_is_r4_type_a0 || (FETCH_Instr_is_i_type_a0 && (src == 1)) || FETCH_Instr_is_r2_type_a0 || FETCH_Instr_is_s_type_a0 || FETCH_Instr_is_b_type_a0);
assign L1_reg_a0[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a0[4:0] : FETCH_Instr_raw_rs2_a0[4:0];
end
// Condition signals must not themselves be conditioned (currently).
assign FETCH_Instr_dest_reg_a0[4:0] = FETCH_Instr_second_issue_div_mul_a0 ? FETCH_Instr_HoldInst_dest_reg_a1 :
FETCH_Instr_second_issue_ld_a0 ? FETCH_Instr_OrigInst_dest_reg_a0 : FETCH_Instr_raw_rd_a0[4:0];
assign FETCH_Instr_dest_reg_valid_a0 = ((FETCH_Instr_valid_decode_a0 && ! FETCH_Instr_is_s_type_a0 && ! FETCH_Instr_is_b_type_a0) || FETCH_Instr_second_issue_a0) &&
| FETCH_Instr_dest_reg_a0; // r0 not valid. TODO: Huh? What about FP? No formal failure?
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2045 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
// Actually load.
assign FETCH_Instr_spec_ld_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_ld_a0;
// CSR decode.
assign FETCH_Instr_is_csr_write_a0 = FETCH_Instr_is_csrrw_instr_a0 || FETCH_Instr_is_csrrwi_instr_a0;
assign FETCH_Instr_is_csr_set_a0 = FETCH_Instr_is_csrrs_instr_a0 || FETCH_Instr_is_csrrsi_instr_a0;
assign FETCH_Instr_is_csr_clear_a0 = FETCH_Instr_is_csrrc_instr_a0 || FETCH_Instr_is_csrrci_instr_a0;
assign FETCH_Instr_is_csr_instr_a0 = FETCH_Instr_is_csr_write_a0 ||
FETCH_Instr_is_csr_set_a0 ||
FETCH_Instr_is_csr_clear_a0;
assign FETCH_Instr_valid_csr_a0 = 1'b0 || FETCH_Instr_is_csr_cycle_a0 || FETCH_Instr_is_csr_cycleh_a0 || FETCH_Instr_is_csr_time_a0 || FETCH_Instr_is_csr_timeh_a0 || FETCH_Instr_is_csr_instret_a0 || FETCH_Instr_is_csr_instreth_a0;
assign FETCH_Instr_csr_trap_a0 = FETCH_Instr_is_csr_instr_a0 && ! FETCH_Instr_valid_csr_a0;
//_\end_source
// Instantiate the program. (This approach is required for an m5-defined name.)
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3226 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3732 as: m5+m5_branch_pred_macro_name()
//_@0
assign FETCH_Instr_pred_taken_a0 = 1'b0;
//_\end_source
//_@0
// Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
assign FETCH_Instr_reg_wr_pending_a0 = FETCH_Instr_ld_a0 && ! FETCH_Instr_second_issue_a0 && 1'b1;
`BOGUS_USE(FETCH_Instr_reg_wr_pending_a0) // Not used if no bypass and no pending.
// ======
// Reg Rd
// ======
// Obtain source register values and pending bit for source registers.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3856 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3744 as: m5+operands( , /src, 2:1)
// Obtain source register values and pending bit for int or fp source registers. Bypass up to 3
// stages.
// It is not necessary to bypass pending, as we could delay the replay, but we implement
// bypass for performance.
// Pending has an additional read for the dest register as we need to replay for write-after-write
// hazard as well as write-after-read. To replay for dest write with the same timing, we must also
// bypass the dest reg's pending bit.
for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src //_/src
// For $is_reg_condition.
logic L1_is_reg_condition_a0;
// For $pending.
logic L1_pending_a0;
// For $reg_value.
logic [31:0] L1_reg_value_a0;
// For $rf_value.
logic [31:0] L1_rf_value_a0;
assign L1_is_reg_condition_a0 = L1_FETCH_Instr_Src[src].L1_is_reg_a0 && FETCH_Instr_valid_decode_a0; // Note: $is_reg can be set for RISC-V sr0.
//_?$is_reg_condition
assign L1_rf_value_a0[31:0] =
FETCH_Instr_Regs_value_a0[L1_FETCH_Instr_Src[src].L1_reg_a0];
/* verilator lint_off WIDTH */ // TODO: Disabling WIDTH to work around what we think is https://github.com/verilator/verilator/issues/1613, when --fmtPackAll is in use.
assign {L1_reg_value_a0[31:0], L1_pending_a0} =
(L1_FETCH_Instr_Src[src].L1_reg_a0 == 5'b0) ? {32'b0, 1'b0} : // Read r0 as 0 (not pending).⌈⌉m5_set(status, ⌈⌉)
// Bypass stages. Both register and pending are bypassed.
// Bypassed registers must be from instructions that are good-path as of this instruction or are 2nd issuing.
{L1_rf_value_a0, FETCH_Instr_Regs_pending_a0[L1_FETCH_Instr_Src[src].L1_reg_a0]};
/* verilator lint_on WIDTH */
// Replay if source register is pending.
assign FETCH_Instr_Src_replay_a0[src] = L1_is_reg_condition_a0 && L1_pending_a0;
end
// Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
assign FETCH_Instr_is_dest_condition_a0 = FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_valid_decode_a0;
//_?$is_dest_condition
assign FETCH_Instr_dest_pending_a0 =
(FETCH_Instr_dest_reg_a0 == 5'b0) ? 1'b0 : // Read r0 as 0 (not pending). Not actually necessary, but it cuts off read of non-existent rs0, which might be an issue for formal verif tools.⌈⌉m5_set(status, ⌈⌉)
// Bypass stages.
FETCH_Instr_Regs_pending_a0[FETCH_Instr_dest_reg_a0];
// Combine replay conditions for pending source or dest registers.
assign FETCH_Instr_pending_replay_a0 = | FETCH_Instr_Src_replay_a0 || (FETCH_Instr_is_dest_condition_a0 && FETCH_Instr_dest_pending_a0);
//_\end_source
for (src = 1; src <= 2; src++) begin : L1c_FETCH_Instr_Src //_/src
// For $dummy.
logic L1_dummy_a0;
assign L1_dummy_a0 = 1'b0; // Dummy signal to pull through $ANY expressions when not building verification harness (since SandPiper currently complains about empty $ANY).
end
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3748 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
assign FETCH_Instr_replay_a0 = (FETCH_Instr_pending_replay_a0 );
// =======
// Execute
// =======
// Instantiate the program. (This approach is required for an m5-defined name.)
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 2080 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3766 as: m5+m5_exe_macro_name(@m5_EXECUTE_STAGE, @m5_RESULT_STAGE)
// if M_EXT is enabled, this handles the stalling logic
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3249 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2082 as: m5+m_extension.
// RISC-V M-Extension instructions in WARP-V are fixed latency
// As of today, to handle those instructions, WARP-V pipeline is stalled for the given latency, and the
// results are written back through a second issue at the end of stalling duration.
// Verilog modules are inherited from PicoRV32, and are located in the ./muldiv directory.
// Since the modules have a fixed latency, their valid signals are instantiated as valid decode for M-type
// instructions is detected, and results are put in /orig_inst scope to be used in second issue.
// This macro handles the stalling logic using a counter, and triggers second issue accordingly.
// latency for division is different for ALTOPS case
// latency for multiplication is 2 cycles in case of ALTOPS,
// but we flop it for 5 cycles (in rslt_mux) to augment the normal
// second issue behavior
// Relative to typical 1-cycle latency instructions.
//_@0
assign FETCH_Instr_second_issue_div_mul_a0 = FETCH_Instr_trigger_next_pc_div_mul_second_issue_a1;
//_@0
assign {FETCH_Instr_div_stall_a0, FETCH_Instr_mul_stall_a0, FETCH_Instr_stall_cnt_a0[5:0]} = FETCH_Instr_reset_a0 ? '0 :
FETCH_Instr_second_issue_div_mul_a0 ? '0 :
(FETCH_Instr_commit_a0 && FETCH_Instr_div_mul_a0) ? {FETCH_Instr_divtype_instr_a0, FETCH_Instr_multype_instr_a0, 6'b1} :
FETCH_Instr_div_stall_a1 ? {1'b1, 1'b0, FETCH_Instr_stall_cnt_a1 + 6'b1} :
FETCH_Instr_mul_stall_a1 ? {1'b0, 1'b1, FETCH_Instr_stall_cnt_a1 + 6'b1} :
'0;
assign FETCH_Instr_stall_cnt_upper_mul_a0 = (FETCH_Instr_stall_cnt_a0 == 5);
assign FETCH_Instr_stall_cnt_upper_div_a0 = (FETCH_Instr_stall_cnt_a0 == 37);
assign FETCH_Instr_trigger_next_pc_div_mul_second_issue_a0 = (FETCH_Instr_div_stall_a0 && FETCH_Instr_stall_cnt_upper_div_a0) || (FETCH_Instr_mul_stall_a0 && FETCH_Instr_stall_cnt_upper_mul_a0);
//_\end_source
// if F_EXT is enabled, this handles the stalling logic
// if B_EXT is enabled, this handles the stalling logic
//_@0
//_?$valid_decode_branch
assign FETCH_Instr_branch_target_a0[31:2] = FETCH_Instr_Pc_a0[31:2] + FETCH_Instr_raw_b_imm_a0[31:2];
assign FETCH_Instr_misaligned_pc_a0 = | FETCH_Instr_raw_b_imm_a0[1:0];
//_?$jump // (JAL, not JALR)
assign FETCH_Instr_jump_target_a0[31:2] = FETCH_Instr_Pc_a0[31:2] + FETCH_Instr_raw_j_imm_a0[31:2];
assign FETCH_Instr_misaligned_jump_target_a0 = FETCH_Instr_raw_j_imm_a0[1];
//_@0
// Execution.
assign FETCH_Instr_valid_exe_a0 = FETCH_Instr_valid_decode_a0; // Execute if we decoded.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2100 as: m5+ifelse(m5_EXT_M, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 2101 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__17.
// Verilog instantiation must happen outside when conditions' scope
assign FETCH_Instr_divblk_valid_a0 = FETCH_Instr_divtype_instr_a0 && FETCH_Instr_commit_a0;
assign FETCH_Instr_mulblk_valid_a0 = FETCH_Instr_multype_instr_a0 && FETCH_Instr_commit_a0;
/* verilator lint_off WIDTH */
/* verilator lint_off CASEINCOMPLETE */
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3286 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2107 as: m5+warpv_mul(|fetch/instr,/mul1, $mulblock_rslt, $wrm, $waitm, $readym, $clk, $resetn, $mul_in1, $mul_in2, $instr_type_mul, $mulblk_valid)
//_/mul1
// instr type is one hot encoding of the required M type instruction
// the idea is to concatenate is_*_instr from WARP-V and pass on to this module
assign FETCH_Instr_Mul1_opcode_a0[2:0] = (FETCH_Instr_instr_type_mul_a0 == 4'b0001) ? 3'b000 : // mull
(FETCH_Instr_instr_type_mul_a0 == 4'b0010) ? 3'b001 : // mulh
(FETCH_Instr_instr_type_mul_a0 == 4'b0100) ? 3'b010 : // mulhsu
(FETCH_Instr_instr_type_mul_a0 == 4'b1000) ? 3'b011 : // mulhu
3'b000 ; // default to mul, but this case
// should not be encountered ideally
assign FETCH_Instr_Mul1_mul_insn_a0[31:0] = {7'b0000001,10'b0011000101,FETCH_Instr_Mul1_opcode_a0,5'b00101,7'b0110011};
// { funct7 ,{rs2, rs1} (X), funct3, rd (X), opcode }
// this module is located in ./muldiv/picorv32_pcpi_fast_mul.sv
/*SV_plus*/
picorv32_pcpi_fast_mul #(.EXTRA_MUL_FFS(1), .EXTRA_INSN_FFS(1), .MUL_CLKGATE(0)) mul(
.clk (FETCH_Instr_clk_a0),
.resetn (FETCH_Instr_resetn_a0),
.pcpi_valid (FETCH_Instr_mulblk_valid_a0),
.pcpi_insn (FETCH_Instr_Mul1_mul_insn_a0),
.pcpi_rs1 (FETCH_Instr_mul_in1_a0),
.pcpi_rs2 (FETCH_Instr_mul_in2_a0),
.pcpi_wr (FETCH_Instr_wrm_a0),
.pcpi_rd (FETCH_Instr_mulblock_rslt_a0[31:0]),
.pcpi_wait (FETCH_Instr_waitm_a0),
.pcpi_ready (FETCH_Instr_readym_a0)
);
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3316 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2108 as: m5+warpv_div(|fetch/instr,/div1, $divblock_rslt, $wrd, $waitd, $readyd, $clk, $resetn, $div_in1, $div_in2, $instr_type_div, >>1$div_stall)
//_/div1
// instr type is one hot encoding of the required M type instruction
// the idea is to concatenate is_*_instr from WARP-V and pass on to this module
assign FETCH_Instr_Div1_opcode_a0[2:0] = (FETCH_Instr_instr_type_div_a0 == 4'b0001 ) ? 3'b100 : // div
(FETCH_Instr_instr_type_div_a0 == 4'b0010 ) ? 3'b101 : // divu
(FETCH_Instr_instr_type_div_a0 == 4'b0100 ) ? 3'b110 : // rem
(FETCH_Instr_instr_type_div_a0 == 4'b1000 ) ? 3'b111 : // remu
3'b100 ; // default to div, but this case
// should not be encountered ideally
assign FETCH_Instr_Div1_div_insn_a0[31:0] = {7'b0000001,10'b0011000101,3'b000,5'b00101,7'b0110011} | (FETCH_Instr_Div1_opcode_a0 << 12);
// { funct7 ,{rs2, rs1} (X), funct3, rd (X), opcode }
// this module is located in ./muldiv/picorv32_div_opt.sv
/*SV_plus*/
picorv32_pcpi_div div(
.clk (FETCH_Instr_clk_a0),
.resetn (FETCH_Instr_resetn_a0),
.pcpi_valid (FETCH_Instr_div_stall_a1),
.pcpi_insn (FETCH_Instr_Div1_div_insn_a0),
.pcpi_rs1 (FETCH_Instr_div_in1_a0),
.pcpi_rs2 (FETCH_Instr_div_in2_a0),
.pcpi_rd (FETCH_Instr_divblock_rslt_a0[31:0]),
.pcpi_wait (FETCH_Instr_waitd_a0),
.pcpi_wr (FETCH_Instr_wrd_a0),
.pcpi_ready (FETCH_Instr_readyd_a0)
);
//_\end_source
// for the division module, the valid signal must be asserted for the entire computation duration, hence >>1$div_stall is used for this purpose
// for multiplication it is just a single cycle pulse to start operating
/* verilator lint_on CASEINCOMPLETE */
/* verilator lint_on WIDTH */
// use $ANY for passing attributes from long-latency div/mul instructions into the pipeline
// stall_cnt_upper_div indicates that the results for div module are ready. The second issue of the instruction takes place
// m5_NON_PIPELINED_BUBBLES after this point (depending on pipeline depth)
// retain till next M-type instruction, to be used again at second issue
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2120 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2144 as: m5+ifelse(m5_EXT_B, 1,
//_\end_source
// hold_inst scope is not needed when long latency instructions are disabled
// ORed with 1'b0 for maintaining correct behavior for all 3 combinations of F & M, only F and only M.
// TODO: This becomes a one-liner once $ANY acts on subscope.
//_/hold_inst
assign {FETCH_Instr_HoldInst_dest_reg_a0[4:0], FETCH_Instr_HoldInst_pc_a0[31:2]} = 1'b0 || (FETCH_Instr_mulblk_valid_a0 || (FETCH_Instr_div_stall_a0 && FETCH_Instr_commit_a0)) ? {FETCH_Instr_dest_reg_a0, FETCH_Instr_pc_a0} : {FETCH_Instr_HoldInst_dest_reg_a1, FETCH_Instr_HoldInst_pc_a1};
for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_HoldInst_Src //_/src
// For $dummy.
logic L1_dummy_a0,
L1_dummy_a1;
assign {L1_dummy_a0} = 1'b0 || (FETCH_Instr_mulblk_valid_a0 || (FETCH_Instr_div_stall_a0 && FETCH_Instr_commit_a0)) ? {L1c_FETCH_Instr_Src[src].L1_dummy_a0} : {L1_dummy_a1};
end
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2211 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
// Compute results for each instruction, independent of decode (power-hungry, but fast).
//_?$valid_exe
assign FETCH_Instr_equal_a0 = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 == L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
//_?$branch
assign FETCH_Instr_taken_a0 =
FETCH_Instr_is_j_type_a0 ||
(FETCH_Instr_is_beq_instr_a0 && FETCH_Instr_equal_a0) ||
(FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_equal_a0) ||
((FETCH_Instr_is_blt_instr_a0 || FETCH_Instr_is_bltu_instr_a0 || FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) &&
((FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) ^
(({(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31-1:0]} <
{(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31-1:0]}
) ^ ((L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] != L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]) & FETCH_Instr_is_bge_instr_a0)
)
)
);
//_?$indirect_jump // (JALR)
assign FETCH_Instr_indirect_jump_full_target_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + FETCH_Instr_raw_i_imm_a0;
assign FETCH_Instr_indirect_jump_target_a0[31:2] = FETCH_Instr_indirect_jump_full_target_a0[31:2];
assign FETCH_Instr_misaligned_indirect_jump_target_a0 = FETCH_Instr_indirect_jump_full_target_a0[1];
//_?$valid_exe
// Compute each individual instruction result, combined per-instruction by a macro.
// TODO: Could provide some macro magic to specify combined instructions w/ a single result and mux select.
// This would reduce code below and probably improve implementation.
assign FETCH_Instr_lui_rslt_a0[31:0] = {FETCH_Instr_raw_u_imm_a0[31:12], 12'b0};
assign FETCH_Instr_auipc_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + FETCH_Instr_raw_u_imm_a0;
assign FETCH_Instr_jal_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + 4;
assign FETCH_Instr_jalr_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + 4;
// Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2249 as: m5+ifelse(m5_INJECT_RETURNING_LD, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 2250 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__21.
assign FETCH_Instr_lb_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_lh_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_lw_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_lbu_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_lhu_rslt_a0[31:0] = 32'b0;
//_\end_source
//_\end_source
assign FETCH_Instr_addi_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + FETCH_Instr_raw_i_imm_a0; // TODO: This has its own adder; could share w/ add/sub.
assign FETCH_Instr_xori_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ FETCH_Instr_raw_i_imm_a0;
assign FETCH_Instr_ori_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | FETCH_Instr_raw_i_imm_a0;
assign FETCH_Instr_andi_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & FETCH_Instr_raw_i_imm_a0;
assign FETCH_Instr_slli_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << FETCH_Instr_raw_i_imm_a0[5:0];
assign FETCH_Instr_srli_intermediate_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 >> FETCH_Instr_raw_i_imm_a0[5:0];
assign FETCH_Instr_srai_intermediate_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] ? FETCH_Instr_srli_intermediate_rslt_a0 | ((32'b0 - 1) << (32 - FETCH_Instr_raw_i_imm_a0[5:0]) ): FETCH_Instr_srli_intermediate_rslt_a0;
assign FETCH_Instr_srl_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 >> L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
assign FETCH_Instr_sra_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] ? FETCH_Instr_srl_rslt_a0 | ((32'b0 - 1) << (32 - L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0]) ): FETCH_Instr_srl_rslt_a0;
assign FETCH_Instr_slti_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] == FETCH_Instr_raw_i_imm_a0[31]) ? FETCH_Instr_sltiu_rslt_a0 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]};
assign FETCH_Instr_sltiu_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < FETCH_Instr_raw_i_imm_a0) ? 1 : 0;
assign FETCH_Instr_srai_rslt_a0[31:0] = FETCH_Instr_srai_intermediate_rslt_a0;
assign FETCH_Instr_srli_rslt_a0[31:0] = FETCH_Instr_srli_intermediate_rslt_a0;
assign FETCH_Instr_add_sub_rslt_a0[31:0] = (FETCH_Instr_raw_funct7_a0[5] == 1) ? L1b_FETCH_Instr_Src[1].L1_reg_value_a0 - L1b_FETCH_Instr_Src[2].L1_reg_value_a0 : L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
assign FETCH_Instr_add_rslt_a0[31:0] = FETCH_Instr_add_sub_rslt_a0;
assign FETCH_Instr_sub_rslt_a0[31:0] = FETCH_Instr_add_sub_rslt_a0;
assign FETCH_Instr_sll_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
assign FETCH_Instr_slt_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] == L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]) ? FETCH_Instr_sltu_rslt_a0 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]};
assign FETCH_Instr_sltu_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < L1b_FETCH_Instr_Src[2].L1_reg_value_a0) ? 1 : 0;
assign FETCH_Instr_xor_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
assign FETCH_Instr_or_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
assign FETCH_Instr_and_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
// CSR read instructions have the same result expression. Counting on synthesis to optimize result mux.
assign FETCH_Instr_csrrw_rslt_a0[31:0] = FETCH_Instr_is_csr_instreth_a0 ? {{0{1'b0}},FETCH_Instr_csr_instreth_a0} : FETCH_Instr_is_csr_instret_a0 ? {{0{1'b0}},FETCH_Instr_csr_instret_a0} : FETCH_Instr_is_csr_timeh_a0 ? {{0{1'b0}},FETCH_Instr_csr_timeh_a0} : FETCH_Instr_is_csr_time_a0 ? {{0{1'b0}},FETCH_Instr_csr_time_a0} : FETCH_Instr_is_csr_cycleh_a0 ? {{0{1'b0}},FETCH_Instr_csr_cycleh_a0} : FETCH_Instr_is_csr_cycle_a0 ? {{0{1'b0}},FETCH_Instr_csr_cycle_a0} : 32'bx;
assign FETCH_Instr_csrrs_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
assign FETCH_Instr_csrrc_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
assign FETCH_Instr_csrrwi_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
assign FETCH_Instr_csrrsi_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
assign FETCH_Instr_csrrci_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
// "M" Extension.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2302 as: m5+ifelse(m5_EXT_M, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 2303 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__23.
// for Verilog modules instantiation
assign FETCH_Instr_clk_a0 = clk;
assign FETCH_Instr_resetn_a0 = !(reset);
assign FETCH_Instr_instr_type_mul_a0[3:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_mulblk_valid_a0 ? {FETCH_Instr_is_mulhu_instr_a0,FETCH_Instr_is_mulhsu_instr_a0,FETCH_Instr_is_mulh_instr_a0,FETCH_Instr_is_mul_instr_a0} : FETCH_Instr_instr_type_mul_a1[3:0];
assign FETCH_Instr_mul_in1_a0[31:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_mulblk_valid_a0 ? L1b_FETCH_Instr_Src[1].L1_reg_value_a0 : FETCH_Instr_mul_in1_a1[31:0];
assign FETCH_Instr_mul_in2_a0[31:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_mulblk_valid_a0 ? L1b_FETCH_Instr_Src[2].L1_reg_value_a0 : FETCH_Instr_mul_in2_a1[31:0];
assign FETCH_Instr_instr_type_div_a0[3:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_divblk_valid_a0 ? {FETCH_Instr_is_remu_instr_a0,FETCH_Instr_is_rem_instr_a0,FETCH_Instr_is_divu_instr_a0,FETCH_Instr_is_div_instr_a0} : FETCH_Instr_instr_type_div_a1[3:0];
assign FETCH_Instr_div_in1_a0[31:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_divblk_valid_a0 ? L1b_FETCH_Instr_Src[1].L1_reg_value_a0 : FETCH_Instr_div_in1_a1[31:0];
assign FETCH_Instr_div_in2_a0[31:0] = FETCH_Instr_reset_a0 ? '0 : FETCH_Instr_divblk_valid_a0 ? L1b_FETCH_Instr_Src[2].L1_reg_value_a0 : FETCH_Instr_div_in2_a1[31:0];
// result signals for div/mul can be pulled down to 0 here, as they are assigned only in the second issue
assign FETCH_Instr_mul_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_mulh_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_mulhsu_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_mulhu_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_div_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_divu_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_rem_rslt_a0[31:0] = 32'b0;
assign FETCH_Instr_remu_rslt_a0[31:0] = 32'b0;
`BOGUS_USE (FETCH_Instr_wrm_a0 FETCH_Instr_wrd_a0 FETCH_Instr_readyd_a0 FETCH_Instr_readym_a0 FETCH_Instr_waitm_a0 FETCH_Instr_waitd_a0)
//_\end_source
//_\end_source
// "F" Extension.
// TODO: Move this under /fpu.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2332 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2406 as: m5+ifelse(m5_EXT_B, 1,
//_\end_source
// CSR logic
// ---------
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1774 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2530 as: m5+riscv_csrs(⌈⌉(m5_csrs)⌈⌉)
// TODO: This doesn't maintain alignment. Need an m5+foreach macro.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR CYCLE
//--------------
//_@0
assign FETCH_Instr_is_csr_cycle_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC00;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__26.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_cycle_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_cycle_hw_wr_a0}} & FETCH_Instr_csr_cycle_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_cycle_a0[31:0] =
(FETCH_Instr_csr_cycle_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycle_hw_wr_value_a0) | (~ FETCH_Instr_csr_cycle_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycle_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__29.
// Next value of the CSR.
assign FETCH_Instr_csr_cycle_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_cycle_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_cycle_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_cycle_a0
? FETCH_Instr_csr_cycle_masked_wr_value_a0 | (FETCH_Instr_upd_csr_cycle_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_cycle_a0
? FETCH_Instr_upd_csr_cycle_a0 | FETCH_Instr_csr_cycle_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_cycle_a0
? FETCH_Instr_upd_csr_cycle_a0 & ~ FETCH_Instr_csr_cycle_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_cycle_a0;
//_\end_source
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR CYCLEH
//--------------
//_@0
assign FETCH_Instr_is_csr_cycleh_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC80;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__30.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_cycleh_hw_wr_a0}} & FETCH_Instr_csr_cycleh_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_cycleh_a0[31:0] =
(FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycleh_hw_wr_value_a0) | (~ FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycleh_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__33.
// Next value of the CSR.
assign FETCH_Instr_csr_cycleh_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_cycleh_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_cycleh_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_cycleh_a0
? FETCH_Instr_csr_cycleh_masked_wr_value_a0 | (FETCH_Instr_upd_csr_cycleh_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_cycleh_a0
? FETCH_Instr_upd_csr_cycleh_a0 | FETCH_Instr_csr_cycleh_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_cycleh_a0
? FETCH_Instr_upd_csr_cycleh_a0 & ~ FETCH_Instr_csr_cycleh_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_cycleh_a0;
//_\end_source
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR TIME
//--------------
//_@0
assign FETCH_Instr_is_csr_time_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC01;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__34.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_time_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_time_hw_wr_a0}} & FETCH_Instr_csr_time_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_time_a0[31:0] =
(FETCH_Instr_csr_time_hw_wr_en_mask_a0 & FETCH_Instr_csr_time_hw_wr_value_a0) | (~ FETCH_Instr_csr_time_hw_wr_en_mask_a0 & FETCH_Instr_csr_time_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__37.
// Next value of the CSR.
assign FETCH_Instr_csr_time_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_time_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_time_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_time_a0
? FETCH_Instr_csr_time_masked_wr_value_a0 | (FETCH_Instr_upd_csr_time_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_time_a0
? FETCH_Instr_upd_csr_time_a0 | FETCH_Instr_csr_time_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_time_a0
? FETCH_Instr_upd_csr_time_a0 & ~ FETCH_Instr_csr_time_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_time_a0;
//_\end_source
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR TIMEH
//--------------
//_@0
assign FETCH_Instr_is_csr_timeh_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC81;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__38.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_timeh_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_timeh_hw_wr_a0}} & FETCH_Instr_csr_timeh_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_timeh_a0[31:0] =
(FETCH_Instr_csr_timeh_hw_wr_en_mask_a0 & FETCH_Instr_csr_timeh_hw_wr_value_a0) | (~ FETCH_Instr_csr_timeh_hw_wr_en_mask_a0 & FETCH_Instr_csr_timeh_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__41.
// Next value of the CSR.
assign FETCH_Instr_csr_timeh_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_timeh_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_timeh_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_timeh_a0
? FETCH_Instr_csr_timeh_masked_wr_value_a0 | (FETCH_Instr_upd_csr_timeh_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_timeh_a0
? FETCH_Instr_upd_csr_timeh_a0 | FETCH_Instr_csr_timeh_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_timeh_a0
? FETCH_Instr_upd_csr_timeh_a0 & ~ FETCH_Instr_csr_timeh_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_timeh_a0;
//_\end_source
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR INSTRET
//--------------
//_@0
assign FETCH_Instr_is_csr_instret_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC02;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__42.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_instret_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_instret_hw_wr_a0}} & FETCH_Instr_csr_instret_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_instret_a0[31:0] =
(FETCH_Instr_csr_instret_hw_wr_en_mask_a0 & FETCH_Instr_csr_instret_hw_wr_value_a0) | (~ FETCH_Instr_csr_instret_hw_wr_en_mask_a0 & FETCH_Instr_csr_instret_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__45.
// Next value of the CSR.
assign FETCH_Instr_csr_instret_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_instret_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_instret_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_instret_a0
? FETCH_Instr_csr_instret_masked_wr_value_a0 | (FETCH_Instr_upd_csr_instret_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_instret_a0
? FETCH_Instr_upd_csr_instret_a0 | FETCH_Instr_csr_instret_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_instret_a0
? FETCH_Instr_upd_csr_instret_a0 & ~ FETCH_Instr_csr_instret_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_instret_a0;
//_\end_source
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1729 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1777 as: m5+riscv_csr(m5_eval(⌈m5_csr_⌉csr⌈_args⌉))
//--------------
// CSR INSTRETH
//--------------
//_@0
assign FETCH_Instr_is_csr_instreth_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC82;
//_@0
// CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
// Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1740 as: m5+ifelse(1, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1741 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__46.
// hw_wr_mask conditioned by hw_wr.
assign FETCH_Instr_csr_instreth_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_instreth_hw_wr_a0}} & FETCH_Instr_csr_instreth_hw_wr_mask_a0;
// The CSR value, updated by side-effect writes.
assign FETCH_Instr_upd_csr_instreth_a0[31:0] =
(FETCH_Instr_csr_instreth_hw_wr_en_mask_a0 & FETCH_Instr_csr_instreth_hw_wr_value_a0) | (~ FETCH_Instr_csr_instreth_hw_wr_en_mask_a0 & FETCH_Instr_csr_instreth_a0);
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1752 as: m5+ifelse(1, RO,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1755 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__49.
// Next value of the CSR.
assign FETCH_Instr_csr_instreth_masked_wr_value_a0[31:0] =
FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
assign FETCH_Instr_csr_instreth_n1[31:0] =
FETCH_Instr_reset_a0 ? 32'b0 :
! FETCH_Instr_commit_a0
? FETCH_Instr_upd_csr_instreth_a0 :
FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_instreth_a0
? FETCH_Instr_csr_instreth_masked_wr_value_a0 | (FETCH_Instr_upd_csr_instreth_a0 & ~ {32{1'b1}}) :
FETCH_Instr_is_csr_set_a0 && FETCH_Instr_is_csr_instreth_a0
? FETCH_Instr_upd_csr_instreth_a0 | FETCH_Instr_csr_instreth_masked_wr_value_a0 :
FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_instreth_a0
? FETCH_Instr_upd_csr_instreth_a0 & ~ FETCH_Instr_csr_instreth_masked_wr_value_a0 :
// No CSR instruction update, only h/w side-effects.
FETCH_Instr_upd_csr_instreth_a0;
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_@0
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1780 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2532 as: m5+riscv_csr_logic()
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1781 as: m5+ifelse(m5_csrs, ⌈⌉, ⌈⌉,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1782 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__50.
// CSR write value for CSR write instructions.
assign FETCH_Instr_csr_wr_value_a0[31:0] = FETCH_Instr_raw_funct3_a0[2] ? {27'b0, FETCH_Instr_raw_rs1_a0} : L1b_FETCH_Instr_Src[1].L1_reg_value_a0;
//_\end_source
//_\end_source
// Counter CSR
//
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1789 as: m5+ifelse(m5_NO_COUNTER_CSRS, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1792 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__52.
// Count within time unit. This is not reset on writes to time CSR, so time CSR is only accurate to time unit.
assign FETCH_Instr_RemainingCyclesWithinTimeUnit_n1[30-1:0] =
(FETCH_Instr_reset_a0 || FETCH_Instr_time_unit_expires_a0) ?
30'd999999999 :
FETCH_Instr_RemainingCyclesWithinTimeUnit_a0 - 30'b1;
assign FETCH_Instr_time_unit_expires_a0 = !( | FETCH_Instr_RemainingCyclesWithinTimeUnit_a0); // reaches zero
assign FETCH_Instr_full_csr_cycle_hw_wr_value_a0[63:0] = {FETCH_Instr_csr_cycleh_a0, FETCH_Instr_csr_cycle_a0 } + 64'b1;
assign FETCH_Instr_full_csr_time_hw_wr_value_a0[63:0] = {FETCH_Instr_csr_timeh_a0, FETCH_Instr_csr_time_a0 } + 64'b1;
assign FETCH_Instr_full_csr_instret_hw_wr_value_a0[63:0] = {FETCH_Instr_csr_instreth_a0, FETCH_Instr_csr_instret_a0} + 64'b1;
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1803 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
// CSR h/w side-effect write signals.
assign FETCH_Instr_csr_cycle_hw_wr_a0 = 1'b1;
assign FETCH_Instr_csr_cycle_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_cycle_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a0[31:0];
assign FETCH_Instr_csr_cycleh_hw_wr_a0 = 1'b1;
assign FETCH_Instr_csr_cycleh_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_cycleh_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a0[63:32];
assign FETCH_Instr_csr_time_hw_wr_a0 = FETCH_Instr_time_unit_expires_a0;
assign FETCH_Instr_csr_time_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_time_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a0[31:0];
assign FETCH_Instr_csr_timeh_hw_wr_a0 = FETCH_Instr_time_unit_expires_a0;
assign FETCH_Instr_csr_timeh_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_timeh_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a0[63:32];
assign FETCH_Instr_csr_instret_hw_wr_a0 = FETCH_Instr_commit_a0;
assign FETCH_Instr_csr_instret_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_instret_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a0[31:0];
assign FETCH_Instr_csr_instreth_hw_wr_a0 = FETCH_Instr_commit_a0;
assign FETCH_Instr_csr_instreth_hw_wr_mask_a0[31:0] = {32{1'b1}};
assign FETCH_Instr_csr_instreth_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a0[63:32];
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1830 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_\end_source
//_\end_source
// For multicore CSRs:
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 1847 as: m5+ifelse(m5_calc(m5_NUM_CORES > 1), 1,
//_\end_source
//_\end_source
// Memory inputs.
//_?$valid_exe
assign FETCH_Instr_unnatural_addr_trap_a0 = (FETCH_Instr_ld_st_word_a0 && (FETCH_Instr_addr_a0[1:0] != 2'b00)) || (FETCH_Instr_ld_st_half_a0 && FETCH_Instr_addr_a0[0]);
assign FETCH_Instr_ld_st_cond_a0 = FETCH_Instr_ld_st_a0 && FETCH_Instr_valid_exe_a0;
//_?$ld_st_cond
assign FETCH_Instr_addr_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + (FETCH_Instr_ld_a0 ? FETCH_Instr_raw_i_imm_a0 : FETCH_Instr_raw_s_imm_a0);
// Hardware assumes natural alignment. Otherwise, trap, and handle in s/w (though no s/w provided).
assign FETCH_Instr_st_cond_a0 = FETCH_Instr_st_a0 && FETCH_Instr_valid_exe_a0;
//_?$st_cond
// Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
assign FETCH_Instr_st_reg_value_a0[31:0] =
L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
assign FETCH_Instr_st_value_a0[31:0] =
FETCH_Instr_ld_st_word_a0 ? FETCH_Instr_st_reg_value_a0 : // word
FETCH_Instr_ld_st_half_a0 ? {2{FETCH_Instr_st_reg_value_a0[15:0]}} : // half
{4{FETCH_Instr_st_reg_value_a0[7:0]}}; // byte
assign FETCH_Instr_st_mask_a0[3:0] =
FETCH_Instr_ld_st_word_a0 ? 4'hf : // word
FETCH_Instr_ld_st_half_a0 ? (FETCH_Instr_addr_a0[1] ? 4'hc : 4'h3) : // half
(4'h1 << FETCH_Instr_addr_a0[1:0]); // byte
// Swizzle bytes for load result (assuming natural alignment) and pass to /orig_load_inst scope
//_?$second_issue_ld
//_/orig_load_inst
assign FETCH_Instr_OrigLoadInst_spec_ld_cond_a0 = FETCH_Instr_OrigLoadInst_spec_ld_a0;
//_?$spec_ld_cond
// (Verilator didn't like indexing $ld_value by signal math, so we do these the long way.)
assign FETCH_Instr_OrigLoadInst_sign_bit_a0 =
! FETCH_Instr_OrigLoadInst_raw_funct3_a0[2] && ( // Signed && ...
FETCH_Instr_OrigLoadInst_ld_st_word_a0 ? FETCH_Instr_OrigLoadInst_ld_value_a0[31] :
FETCH_Instr_OrigLoadInst_ld_st_half_a0 ? (FETCH_Instr_OrigLoadInst_addr_a0[1] ? FETCH_Instr_OrigLoadInst_ld_value_a0[31] : FETCH_Instr_OrigLoadInst_ld_value_a0[15]) :
((FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b00) ? FETCH_Instr_OrigLoadInst_ld_value_a0[7] :
(FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b01) ? FETCH_Instr_OrigLoadInst_ld_value_a0[15] :
(FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b10) ? FETCH_Instr_OrigLoadInst_ld_value_a0[23] :
FETCH_Instr_OrigLoadInst_ld_value_a0[31]
)
);
assign {FETCH_Instr_OrigLoadInst_ld_rslt_a0[31:0], FETCH_Instr_OrigLoadInst_ld_mask_a0[3:0]} =
FETCH_Instr_OrigLoadInst_ld_st_word_a0 ? {FETCH_Instr_OrigLoadInst_ld_value_a0, 4'b1111} :
FETCH_Instr_OrigLoadInst_ld_st_half_a0 ? {{16{FETCH_Instr_OrigLoadInst_sign_bit_a0}}, FETCH_Instr_OrigLoadInst_addr_a0[1] ? {FETCH_Instr_OrigLoadInst_ld_value_a0[31:16], 4'b1100} :
{FETCH_Instr_OrigLoadInst_ld_value_a0[15:0] , 4'b0011}} :
{{24{FETCH_Instr_OrigLoadInst_sign_bit_a0}}, (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b00) ? {FETCH_Instr_OrigLoadInst_ld_value_a0[7:0] , 4'b0001} :
(FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b01) ? {FETCH_Instr_OrigLoadInst_ld_value_a0[15:8] , 4'b0010} :
(FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b10) ? {FETCH_Instr_OrigLoadInst_ld_value_a0[23:16], 4'b0100} :
{FETCH_Instr_OrigLoadInst_ld_value_a0[31:24], 4'b1000}};
`BOGUS_USE(FETCH_Instr_OrigLoadInst_ld_mask_a0) // It's only for formal verification.
// ISA-specific trap conditions:
// I can't see in the spec which of these is to commit results. I've made choices that make riscv-formal happy.
assign FETCH_Instr_non_aborting_isa_trap_a0 = (FETCH_Instr_branch_a0 && FETCH_Instr_taken_a0 && FETCH_Instr_misaligned_pc_a0) ||
(FETCH_Instr_jump_a0 && FETCH_Instr_misaligned_jump_target_a0) ||
(FETCH_Instr_indirect_jump_a0 && FETCH_Instr_misaligned_indirect_jump_target_a0);
assign FETCH_Instr_aborting_isa_trap_a0 = (FETCH_Instr_ld_st_a0 && FETCH_Instr_unnatural_addr_trap_a0) ||
FETCH_Instr_csr_trap_a0;
//_@0
// Mux the correct result.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1871 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 2591 as: m5+riscv_rslt_mux_expr()
// in case of second issue, the results are pulled out of the /orig_inst or /load_inst scope.
// no alignment is needed as the rslt mux and the long latency results both appear in the same pipestage.
// in the case of second isssue for multiplication with ALTOPS enabled (or running formal checks for M extension),
// the module gives out the result in two cycles but we explicitly flop the $mul_rslt
// (by alignment with 3+NON_PIPELINED_BUBBLES to augment the 5 cycle behavior of the mul operation)
assign FETCH_Instr_rslt_a0[31:0] =
FETCH_Instr_second_issue_ld_a0 ? FETCH_Instr_OrigLoadInst_ld_rslt_a0 :
(FETCH_Instr_second_issue_div_mul_a0 && FETCH_Instr_stall_cnt_upper_div_a1) ? FETCH_Instr_divblock_rslt_a0 :
(FETCH_Instr_second_issue_div_mul_a0 && FETCH_Instr_stall_cnt_upper_mul_a1) ? FETCH_Instr_mulblock_rslt_a0 :
32'b0 |
({32{FETCH_Instr_is_lui_instr_a0}} & FETCH_Instr_lui_rslt_a0) |
({32{FETCH_Instr_is_auipc_instr_a0}} & FETCH_Instr_auipc_rslt_a0) |
({32{FETCH_Instr_is_jal_instr_a0}} & FETCH_Instr_jal_rslt_a0) |
({32{FETCH_Instr_is_jalr_instr_a0}} & FETCH_Instr_jalr_rslt_a0) |
({32{FETCH_Instr_is_lb_instr_a0}} & FETCH_Instr_lb_rslt_a0) |
({32{FETCH_Instr_is_lh_instr_a0}} & FETCH_Instr_lh_rslt_a0) |
({32{FETCH_Instr_is_lw_instr_a0}} & FETCH_Instr_lw_rslt_a0) |
({32{FETCH_Instr_is_lbu_instr_a0}} & FETCH_Instr_lbu_rslt_a0) |
({32{FETCH_Instr_is_lhu_instr_a0}} & FETCH_Instr_lhu_rslt_a0) |
({32{FETCH_Instr_is_addi_instr_a0}} & FETCH_Instr_addi_rslt_a0) |
({32{FETCH_Instr_is_slti_instr_a0}} & FETCH_Instr_slti_rslt_a0) |
({32{FETCH_Instr_is_sltiu_instr_a0}} & FETCH_Instr_sltiu_rslt_a0) |
({32{FETCH_Instr_is_xori_instr_a0}} & FETCH_Instr_xori_rslt_a0) |
({32{FETCH_Instr_is_ori_instr_a0}} & FETCH_Instr_ori_rslt_a0) |
({32{FETCH_Instr_is_andi_instr_a0}} & FETCH_Instr_andi_rslt_a0) |
({32{FETCH_Instr_is_slli_instr_a0}} & FETCH_Instr_slli_rslt_a0) |
({32{FETCH_Instr_is_srli_instr_a0}} & FETCH_Instr_srli_rslt_a0) |
({32{FETCH_Instr_is_srai_instr_a0}} & FETCH_Instr_srai_rslt_a0) |
({32{FETCH_Instr_is_add_instr_a0}} & FETCH_Instr_add_rslt_a0) |
({32{FETCH_Instr_is_sub_instr_a0}} & FETCH_Instr_sub_rslt_a0) |
({32{FETCH_Instr_is_sll_instr_a0}} & FETCH_Instr_sll_rslt_a0) |
({32{FETCH_Instr_is_slt_instr_a0}} & FETCH_Instr_slt_rslt_a0) |
({32{FETCH_Instr_is_sltu_instr_a0}} & FETCH_Instr_sltu_rslt_a0) |
({32{FETCH_Instr_is_xor_instr_a0}} & FETCH_Instr_xor_rslt_a0) |
({32{FETCH_Instr_is_srl_instr_a0}} & FETCH_Instr_srl_rslt_a0) |
({32{FETCH_Instr_is_sra_instr_a0}} & FETCH_Instr_sra_rslt_a0) |
({32{FETCH_Instr_is_or_instr_a0}} & FETCH_Instr_or_rslt_a0) |
({32{FETCH_Instr_is_and_instr_a0}} & FETCH_Instr_and_rslt_a0) |
({32{FETCH_Instr_is_csrrw_instr_a0}} & FETCH_Instr_csrrw_rslt_a0) |
({32{FETCH_Instr_is_csrrs_instr_a0}} & FETCH_Instr_csrrs_rslt_a0) |
({32{FETCH_Instr_is_csrrc_instr_a0}} & FETCH_Instr_csrrc_rslt_a0) |
({32{FETCH_Instr_is_csrrwi_instr_a0}} & FETCH_Instr_csrrwi_rslt_a0) |
({32{FETCH_Instr_is_csrrsi_instr_a0}} & FETCH_Instr_csrrsi_rslt_a0) |
({32{FETCH_Instr_is_csrrci_instr_a0}} & FETCH_Instr_csrrci_rslt_a0) |
({32{FETCH_Instr_is_mul_instr_a0}} & FETCH_Instr_mul_rslt_a0) |
({32{FETCH_Instr_is_mulh_instr_a0}} & FETCH_Instr_mulh_rslt_a0) |
({32{FETCH_Instr_is_mulhsu_instr_a0}} & FETCH_Instr_mulhsu_rslt_a0) |
({32{FETCH_Instr_is_mulhu_instr_a0}} & FETCH_Instr_mulhu_rslt_a0) |
({32{FETCH_Instr_is_div_instr_a0}} & FETCH_Instr_div_rslt_a0) |
({32{FETCH_Instr_is_divu_instr_a0}} & FETCH_Instr_divu_rslt_a0) |
({32{FETCH_Instr_is_rem_instr_a0}} & FETCH_Instr_rem_rslt_a0) |
({32{FETCH_Instr_is_remu_instr_a0}} & FETCH_Instr_remu_rslt_a0);
//_\end_source
//_\end_source
//_@0
//_@0
// =======
// Control
// =======
// A version of PC we can pull through $ANYs.
assign FETCH_Instr_pc_a0[31:2] = FETCH_Instr_Pc_a0[31:2];
`BOGUS_USE(FETCH_Instr_pc_a0)
// Execute stage redirect conditions.
assign FETCH_Instr_non_pipelined_a0 = FETCH_Instr_div_mul_a0 ;
assign FETCH_Instr_replay_trap_a0 = 1'b0;
assign FETCH_Instr_aborting_trap_a0 = (FETCH_Instr_replay_trap_a0 || (FETCH_Instr_valid_decode_a0 && FETCH_Instr_illegal_a0) || FETCH_Instr_aborting_isa_trap_a0);
assign FETCH_Instr_non_aborting_trap_a0 = FETCH_Instr_non_aborting_isa_trap_a0;
assign FETCH_Instr_mispred_branch_a0 = FETCH_Instr_branch_a0 && ! (FETCH_Instr_conditional_branch_a0 && (FETCH_Instr_taken_a0 == FETCH_Instr_pred_taken_a0));
//_?$valid_decode_branch
assign FETCH_Instr_branch_redir_pc_a0[31:2] =
// If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
FETCH_Instr_branch_target_a0;
assign FETCH_Instr_trap_target_a0[31:2] = FETCH_Instr_replay_trap_a0 ? FETCH_Instr_Pc_a0 : {30{1'b1}}; // TODO: What should this be? Using ones to terminate test for now.
// Determine whether the instruction should commit it's result.
//
// Abort: Instruction triggers a condition causing a no-commit.
// Commit: Ultimate decision to commit results of this instruction, considering aborts and
// prior-instruction redirects (good-path)
//
// Treatment of loads:
// Loads will commit. They write a garbage value and "pending" to the register file.
// Returning loads clobber an instruction. This instruction is $abort'ed (as is the
// returning load, since they are one in the same). Returning load must explicitly
// write results.
//
assign FETCH_Instr_abort_a0 = 1'b0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_NoFetch_a0 || FETCH_Instr_replay_a0 || FETCH_Instr_aborting_trap_a0; // Note that register bypass logic requires that abort conditions also redirect.
// $commit = m5_prev_instr_valid_through(m5_MAX_REDIRECT_BUBBLES + 1), where +1 accounts for this
// instruction's redirects. However, to meet timing, we consider this instruction separately, so,
// commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
// Normal case:
assign FETCH_Instr_good_path_a0 = (! FETCH_Instr_reset_a0 && FETCH_Instr_next_good_path_mask_a0[1]);
assign FETCH_Instr_commit_a0 = FETCH_Instr_good_path_a0 && ! FETCH_Instr_abort_a0;
// Conditions that commit results.
assign FETCH_Instr_valid_dest_reg_valid_a0 = (FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_commit_a0) || (FETCH_Instr_second_issue_a0 );
assign FETCH_Instr_valid_ld_a0 = FETCH_Instr_ld_a0 && FETCH_Instr_commit_a0;
assign FETCH_Instr_valid_st_a0 = FETCH_Instr_st_a0 && FETCH_Instr_commit_a0;
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3103 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3832 as: m5+fixed_latency_fake_memory(/top, 0)
// This macro assumes little-endian.
//_|fetch
//_/instr
// ====
// Load
// ====
//_@0
/* DMEM_STYLE: ARRAY */
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3113 as: m5+ifelse(m5_DMEM_STYLE, STUBBED,
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3158 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__59.
// Array. Required for VIZ.
for (bank = 0; bank <= 3; bank++) begin : L1_FETCH_Instr_Bank //_/bank
// For $addr.
logic [31:0] L1_addr_a0;
// For $ld_data.
logic [(32 / 4) - 1 : 0] L1_ld_data_a0;
// For $spec_ld.
logic L1_spec_ld_a0;
// For $st_mask.
logic [3:0] L1_st_mask_a0;
// For $st_value.
logic [31:0] L1_st_value_a0;
// For $valid_st.
logic L1_valid_st_a0;
// For /mem$Value.
logic [(32 / 4) - 1 : 0] L1_Mem_Value_a0 [31:0];
assign {L1_addr_a0[31:0], L1_spec_ld_a0, L1_st_mask_a0[3:0], L1_st_value_a0[31:0], L1_valid_st_a0} = {FETCH_Instr_addr_a0, FETCH_Instr_spec_ld_a0, FETCH_Instr_st_mask_a0, FETCH_Instr_st_value_a0, FETCH_Instr_valid_st_a0}; // Find signal from outside of /bank.
//_/mem
//_?$spec_ld
assign L1_ld_data_a0[(32 / 4) - 1 : 0] = L1_Mem_Value_a0[L1_addr_a0[4 + 2 : 2]];
// Array writes are not currently permitted to use assignment
// syntax, so \always_comb is used, and this must be outside of
// when conditions, so we need to use if. <<1 because no <= support
// in this context. (This limitation will be lifted.)
// =====
// Store
// =====
/*SV_plus*/
always @ (posedge clk) begin
if (L1_valid_st_a0 && L1_st_mask_a0[bank])
L1_Mem_Value_a0[L1_addr_a0[4 + 2 : 2]][(32 / 4) - 1 : 0] <= L1_st_value_a0[(bank + 1) * (32 / 4) - 1: bank * (32 / 4)];
end
end
// Combine $ld_data per bank, assuming little-endian.
//$ld_data[m5_WORD_RANGE] = /bank[*]$ld_data;
// Unfortunately formal verification tools can't handle multiple packed dimensions produced by the expression above, so we
// build the concatination.
assign FETCH_Instr_ld_data_a0[31:0] = {L1_FETCH_Instr_Bank[3].L1_ld_data_a0, L1_FETCH_Instr_Bank[2].L1_ld_data_a0, L1_FETCH_Instr_Bank[1].L1_ld_data_a0, L1_FETCH_Instr_Bank[0].L1_ld_data_a0};
//_\end_source
//_\end_source
//_\end_source
//_\end_source
// Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
// right alignment.
//_|mem
//_/data
// This becomes a one-liner once $ANY acts on subscopes.
//_@0
assign {MEM_Data_addr_a0[1:0], MEM_Data_dest_reg_a0[4:0], MEM_Data_ld_st_half_a0, MEM_Data_ld_st_word_a0, MEM_Data_pc_a0[31:2], MEM_Data_raw_funct3_a0[2], MEM_Data_spec_ld_a0, MEM_Data_valid_ld_a0} = {FETCH_Instr_addr_a0[1:0], FETCH_Instr_dest_reg_a0, FETCH_Instr_ld_st_half_a0, FETCH_Instr_ld_st_word_a0, FETCH_Instr_pc_a0, FETCH_Instr_raw_funct3_a0[2], FETCH_Instr_spec_ld_a0, FETCH_Instr_valid_ld_a0};
for (src = 1; src <= 2; src++) begin : L1_MEM_Data_Src //_/src
// For $dummy.
logic L1_dummy_a0,
L1_dummy_a1;
assign {L1_dummy_a0} = {L1c_FETCH_Instr_Src[src].L1_dummy_a0};
end
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3195 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
// For consistency with other memories, assign $ld_value in @m5_MEM_WR_STAGE+1.
//_@1
assign MEM_Data_ld_value_a1[31:0] = FETCH_Instr_ld_data_a1;
//_\end_source
//_|fetch
//_/instr
// =========
// Reg Write
// =========
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3906 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3838 as: m5+rf_wr(/regs, m5_REGS_RANGE, /instr$valid_dest_reg_valid, /instr$dest_reg, /instr$rslt, /instr$reg_wr_pending)
/* verilator lint_save */
/* verilator lint_on WIDTH */
//_@0
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3910 as: m5+ifelse(m5_RF_STYLE, STUBBED,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3915 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__62.
// Reg Write (Floating Point Register)
/*SV_plus*/
always @ (posedge clk) begin
if (FETCH_Instr_valid_dest_reg_valid_a0)
FETCH_Instr_Regs_value_a0[FETCH_Instr_dest_reg_a0][31:0] <= FETCH_Instr_rslt_a0;
end
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3923 as: m5+ifelse(m5_PENDING_ENABLED, 1,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 3924 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__63.
// Write $pending along with $value, but coded differently because it must be reset.
for (regs = 1; regs <= 31; regs++) begin : L1_FETCH_Instr_Regs //_/regs
assign FETCH_Instr_Regs_pending_n1[regs] = ! FETCH_Instr_reset_a0 && (((regs == FETCH_Instr_dest_reg_a0) && FETCH_Instr_valid_dest_reg_valid_a0) ? FETCH_Instr_reg_wr_pending_a0 : FETCH_Instr_Regs_pending_a0[regs]);
end
//_\end_source
//_\end_source
/* verilator lint_restore */
//_\end_source
// ======
// FPU RF
// ======
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 3843 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_@0
`BOGUS_USE(L1_FETCH_Instr_OrigInst_Src[2].L1_dummy_a0) // To pull $dummy through $ANY expressions, avoiding empty expressions.
// TODO. Seperate the $rslt and $reg_wr_pending committed to both "int" and "fpu" regs.
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 6069 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6115 as: m5+warpv_makerchip_tb()
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 1185 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6072 as: m5+m5_tb_macro_name()
//_|fetch
//_/instr
//_@0
assign FETCH_Instr_passed_a0 = ! FETCH_Instr_reset_a0 && (FETCH_Instr_Pc_a0 == (16 - 1)) && FETCH_Instr_good_path_a0;
assign FETCH_Instr_failed_a0 = cyc_cnt > 200 ;
//============================//
// //
// MINI-CPU //
// //
//============================//
//_\end_source
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 6054 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6116 as: m5+makerchip_pass_fail()
//_|done
//_@0
// Assert these to end simulation (before Makerchip cycle limit).
assign passed = & FETCH_Instr_passed_a0;
assign failed = | FETCH_Instr_failed_a0;
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 5394 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 6119 as: m5+cpu_viz.
/* CPU_VIZ HERE */
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4381 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5400 as: m5+m5_viz_logic_macro_name()
// Code that supports
//_|fetch
//_@0
//_/instr
// A type-independent immediate value, for debug. (For R-type, funct7 is used as immediate).
assign FETCH_Instr_imm_value_a0[31:0] =
({32{FETCH_Instr_is_i_type_a0}} & FETCH_Instr_raw_i_imm_a0) |
({32{FETCH_Instr_is_r_type_a0}} & {25'b0, FETCH_Instr_raw_funct7_a0}) |
({32{FETCH_Instr_is_s_type_a0}} & FETCH_Instr_raw_s_imm_a0) |
({32{FETCH_Instr_is_b_type_a0}} & FETCH_Instr_raw_b_imm_a0) |
({32{FETCH_Instr_is_u_type_a0}} & FETCH_Instr_raw_u_imm_a0) |
({32{FETCH_Instr_is_j_type_a0}} & FETCH_Instr_raw_j_imm_a0);
assign FETCH_Instr_imm_valid_a0 = FETCH_Instr_is_i_type_a0 || FETCH_Instr_is_r_type_a0 || FETCH_Instr_is_s_type_a0 || FETCH_Instr_is_b_type_a0 || FETCH_Instr_is_u_type_a0 || FETCH_Instr_is_j_type_a0;
//_\end_source
//_|fetch
//_@0
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 5384 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5403 as: m5+layout_viz(⌈left: 0, top: 0, width: 451, height: 251⌉, "#7AD7F0")
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4399 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5405 as: m5+instruction_in_memory.
for (instr_mem = 0; instr_mem <= 15; instr_mem++) begin : L1b_FETCH_InstrMem //_/instr_mem
end
//_\end_source
//_/instr
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4920 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5408 as: m5+instruction(⌈left: 10, top: 0⌉)
//_?$valid_decode
// For debug.
assign FETCH_Instr_mnemonic_a0[10*8-1:0] = FETCH_Instr_is_lui_instr_a0 ? "LUI " : FETCH_Instr_is_auipc_instr_a0 ? "AUIPC " : FETCH_Instr_is_jal_instr_a0 ? "JAL " : FETCH_Instr_is_jalr_instr_a0 ? "JALR " : FETCH_Instr_is_beq_instr_a0 ? "BEQ " : FETCH_Instr_is_bne_instr_a0 ? "BNE " : FETCH_Instr_is_blt_instr_a0 ? "BLT " : FETCH_Instr_is_bge_instr_a0 ? "BGE " : FETCH_Instr_is_bltu_instr_a0 ? "BLTU " : FETCH_Instr_is_bgeu_instr_a0 ? "BGEU " : FETCH_Instr_is_lb_instr_a0 ? "LB " : FETCH_Instr_is_lh_instr_a0 ? "LH " : FETCH_Instr_is_lw_instr_a0 ? "LW " : FETCH_Instr_is_lbu_instr_a0 ? "LBU " : FETCH_Instr_is_lhu_instr_a0 ? "LHU " : FETCH_Instr_is_sb_instr_a0 ? "SB " : FETCH_Instr_is_sh_instr_a0 ? "SH " : FETCH_Instr_is_sw_instr_a0 ? "SW " : FETCH_Instr_is_addi_instr_a0 ? "ADDI " : FETCH_Instr_is_slti_instr_a0 ? "SLTI " : FETCH_Instr_is_sltiu_instr_a0 ? "SLTIU " : FETCH_Instr_is_xori_instr_a0 ? "XORI " : FETCH_Instr_is_ori_instr_a0 ? "ORI " : FETCH_Instr_is_andi_instr_a0 ? "ANDI " : FETCH_Instr_is_slli_instr_a0 ? "SLLI " : FETCH_Instr_is_srli_instr_a0 ? "SRLI " : FETCH_Instr_is_srai_instr_a0 ? "SRAI " : FETCH_Instr_is_add_instr_a0 ? "ADD " : FETCH_Instr_is_sub_instr_a0 ? "SUB " : FETCH_Instr_is_sll_instr_a0 ? "SLL " : FETCH_Instr_is_slt_instr_a0 ? "SLT " : FETCH_Instr_is_sltu_instr_a0 ? "SLTU " : FETCH_Instr_is_xor_instr_a0 ? "XOR " : FETCH_Instr_is_srl_instr_a0 ? "SRL " : FETCH_Instr_is_sra_instr_a0 ? "SRA " : FETCH_Instr_is_or_instr_a0 ? "OR " : FETCH_Instr_is_and_instr_a0 ? "AND " : FETCH_Instr_is_csrrw_instr_a0 ? "CSRRW " : FETCH_Instr_is_csrrs_instr_a0 ? "CSRRS " : FETCH_Instr_is_csrrc_instr_a0 ? "CSRRC " : FETCH_Instr_is_csrrwi_instr_a0 ? "CSRRWI " : FETCH_Instr_is_csrrsi_instr_a0 ? "CSRRSI " : FETCH_Instr_is_csrrci_instr_a0 ? "CSRRCI " : FETCH_Instr_is_mul_instr_a0 ? "MUL " : FETCH_Instr_is_mulh_instr_a0 ? "MULH " : FETCH_Instr_is_mulhsu_instr_a0 ? "MULHSU " : FETCH_Instr_is_mulhu_instr_a0 ? "MULHU " : FETCH_Instr_is_div_instr_a0 ? "DIV " : FETCH_Instr_is_divu_instr_a0 ? "DIVU " : FETCH_Instr_is_rem_instr_a0 ? "REM " : FETCH_Instr_is_remu_instr_a0 ? "REMU " : "ILLEGAL ";
`BOGUS_USE(FETCH_Instr_mnemonic_a0)
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4498 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5409 as: m5+registers(/instr, int, Int RF, , 2, ⌈left: 350 + 605, top: 10⌉)
// /regs or /fpu_regs
for (src = 1; src <= 2; src++) begin : L1d_FETCH_Instr_Src //_/src
// There is an issue (#406) with \viz code indexing causing signals to be packed, and if a packed value
// has different fields on different clocks, Verilator throws warnings.
// These are unconditioned versions of the problematic signals.
assign FETCH_Instr_Src_unconditioned_reg_a0[src][4:0] = L1_FETCH_Instr_Src[src].L1_reg_a0;
assign FETCH_Instr_Src_unconditioned_is_reg_a0[src] = L1_FETCH_Instr_Src[src].L1_is_reg_a0;
assign FETCH_Instr_Src_unconditioned_reg_value_a0[src][31:0] = L1b_FETCH_Instr_Src[src].L1_reg_value_a0;
end
for (regs = 1; regs <= 31; regs++) begin : L1b_FETCH_Instr_Regs //_/regs
end
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4891 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5410 as: m5+register_csr(/regcsr, ⌈left: 103 + 605, top: 190⌉)
//_/regcsr
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 4585 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5411 as: m5+pipeline_control_viz(/pipe_ctrl, ⌈left: 103 + 605, top: 265 + 18 * m5_num_csrs, width: 220, height: 330⌉)
assign FETCH_Instr_first_issue_a0 = FETCH_Instr_valid_ld_a0 || FETCH_Instr_non_pipelined_a0;
//_/pipe_ctrl
//_/logic_diagram
//_/waterfall
for (pipe_ctrl_instr = 0; pipe_ctrl_instr <= 2; pipe_ctrl_instr++) begin : L1_FETCH_Instr_PipeCtrl_Waterfall_PipeCtrlInstr //_/pipe_ctrl_instr // Zero on the bottom. See this.getInstrIndex().
for (pipe_ctrl_stage = 0; pipe_ctrl_stage <= 1; pipe_ctrl_stage++) begin : L2_PipeCtrlStage //_/pipe_ctrl_stage
end
end
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5412 as: m5+ifelse(m5_EXT_F, 1,
//_\end_source
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 5249 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5417 as: m5+memory_viz(/bank[m5_calc(m5_ADDRS_PER_WORD-1):0] , /mem[m5_DATA_MEM_WORDS_RANGE], ⌈left: 10 + (550 + 605) -10 + m5_if(m5_EXT_F, ⌈m5_VIZ_MEM_LEFT_ADJUST⌉, 0), top: 10⌉)
//_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88 // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv, 5250 as: m5+ifelse(m5_DMEM_STYLE, ARRAY,
//_\source /raw.githubusercontent.com/stevehoover/warpv/b89fa754262d7d369cf991c09a7c438bc94dd260/warpv.tlv 5251 // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__66.
for (mem = 0; mem <= 31; mem++) begin : L1_FETCH_Instr_Mem //_/mem
end
for (bank = 0; bank <= 3; bank++) begin : L1b_FETCH_Instr_Bank //_/bank
for (mem = 0; mem <= 31; mem++) begin : L2b_Mem //_/mem
end
end
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\end_source
//_\SV
endmodule
// Undefine macros defined by SandPiper.
`undef BOGUS_USE
